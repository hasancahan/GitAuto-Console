#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GitAuto GUI - Windows Uygulamasƒ±
Adƒ±m adƒ±m ilerleyen modern aray√ºz ile Git repository y√∂netimi
"""

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext, filedialog
import os
import subprocess
import sys
from pathlib import Path
import threading
import queue

class GitAutoGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("üöÄ GitAuto - Adƒ±m Adƒ±m Git Repository Y√∂netimi")
        self.root.geometry("900x900")
        self.root.resizable(True, True)
        
        # Modern stil tanƒ±mlamalarƒ±
        self.setup_styles()
        
        # Ana deƒüi≈ükenler
        self.project_name = tk.StringVar()
        self.github_username = tk.StringVar()
        self.commit_message = tk.StringVar(value="first commit")
        self.selected_branch = tk.StringVar(value="main")
        self.readme_var = tk.StringVar(value="keep")
        self.current_directory = os.getcwd()
        
        # Git durumu
        self.git_installed = False
        self.git_repo_exists = False
        
        # Adƒ±m y√∂netimi
        self.current_step = 0
        self.total_steps = 5
        
        # Log mesajlarƒ± i√ßin queue
        self.log_queue = queue.Queue()
        
        # Aray√ºz olu≈ütur
        self.create_widgets()
        
        # ƒ∞lk adƒ±mƒ± g√∂ster
        self.show_step(0)
        
        # Git durumunu kontrol et
        self.check_git_status()
        
        # Log g√ºncellemelerini ba≈ülat
        self.update_log()

    def setup_styles(self):
        """Modern CSS-style buton ve widget stilleri tanƒ±mla"""
        style = ttk.Style()
        
        # Primary buton stili (mavi)
        style.configure("Primary.TButton",
                       background="#2563eb",
                       foreground="white",
                       borderwidth=0,
                       focuscolor="none",
                       font=("Segoe UI", 10, "bold"))
        
        style.map("Primary.TButton",
                 background=[("active", "#1d4ed8"), ("pressed", "#1e40af")],
                 foreground=[("active", "white"), ("pressed", "white")])
        
        # Accent buton stili (ye≈üil)
        style.configure("Accent.TButton",
                       background="#059669",
                       foreground="white",
                       borderwidth=0,
                       focuscolor="none",
                       font=("Segoe UI", 10, "bold"))
        
        style.map("Accent.TButton",
                 background=[("active", "#047857"), ("pressed", "#065f46")],
                 foreground=[("active", "white"), ("pressed", "white")])
        
        # Secondary buton stili (gri)
        style.configure("Secondary.TButton",
                       background="#64748b",
                       foreground="white",
                       borderwidth=0,
                       focuscolor="none",
                       font=("Segoe UI", 10))
        
        style.map("Secondary.TButton",
                 background=[("active", "#475569"), ("pressed", "#334155")],
                 foreground=[("active", "white"), ("pressed", "white")])
        
        # Progress bar stili
        style.configure("Accent.Horizontal.TProgressbar",
                       background="#2563eb",
                       troughcolor="#e2e8f0",
                       borderwidth=0,
                       lightcolor="#3b82f6",
                       darkcolor="#1d4ed8")
        
        # LabelFrame stili
        style.configure("TLabelframe",
                       background="#ffffff",
                       borderwidth=1,
                       relief="solid")
        
        style.configure("TLabelframe.Label",
                       font=("Segoe UI", 11, "bold"),
                       foreground="#1e293b",
                       background="#ffffff")
        
        # Entry stili
        style.configure("TEntry",
                       fieldbackground="#f8fafc",
                       borderwidth=1,
                       relief="solid",
                       focuscolor="#2563eb")
        
        # Combobox stili
        style.configure("TCombobox",
                       fieldbackground="#f8fafc",
                       borderwidth=1,
                       relief="solid",
                       focuscolor="#2563eb")
        
        # Frame stili
        style.configure("TFrame",
                       background="#ffffff")
        
        # Radiobutton stili
        style.configure("TRadiobutton",
                       background="#ffffff",
                       font=("Segoe UI", 10),
                       foreground="#1e293b")
        
        style.map("TRadiobutton",
                 background=[("active", "#f1f5f9"), ("selected", "#dbeafe")],
                 foreground=[("active", "#1e293b"), ("selected", "#1e40af")])

    def create_widgets(self):
        """Adƒ±m adƒ±m ilerleyen widget'larƒ± olu≈ütur"""
        # Ana frame
        main_frame = ttk.Frame(self.root, padding="20")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Grid aƒüƒ±rlƒ±klarƒ±
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        
        # Ba≈ülƒ±k frame
        title_frame = ttk.Frame(main_frame)
        title_frame.grid(row=0, column=0, pady=(0, 20), sticky=(tk.W, tk.E))
        title_frame.columnconfigure(0, weight=1)
        
        title_label = ttk.Label(title_frame, 
                               text="üöÄ GitAuto", 
                               font=("Segoe UI", 24, "bold"),
                               foreground="#2563eb")
        title_label.grid(row=0, column=0, pady=(0, 5))
        
        subtitle_label = ttk.Label(title_frame, 
                                   text="Adƒ±m Adƒ±m Git Repository Y√∂netimi", 
                                   font=("Segoe UI", 12),
                                   foreground="#64748b")
        subtitle_label.grid(row=1, column=0)
        
        # Adƒ±m g√∂stergesi
        step_frame = ttk.Frame(main_frame)
        step_frame.grid(row=1, column=0, pady=(0, 20), sticky=(tk.W, tk.E))
        step_frame.columnconfigure(0, weight=1)
        
        self.step_label = ttk.Label(step_frame, 
                                   text="Adƒ±m 1/5: Proje Bilgileri", 
                                   font=("Segoe UI", 14, "bold"),
                                   foreground="#1e293b")
        self.step_label.grid(row=0, column=0, pady=(0, 10))
        
        # Adƒ±m progress bar
        self.step_progress = ttk.Progressbar(step_frame, 
                                            mode='determinate', 
                                            style="Accent.Horizontal.TProgressbar",
                                            length=400)
        self.step_progress.grid(row=1, column=0)
        self.step_progress['value'] = 20
        
        # ƒ∞√ßerik frame - her adƒ±mda deƒüi≈üecek
        self.content_frame = ttk.Frame(main_frame)
        self.content_frame.grid(row=2, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 20))
        self.content_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(2, weight=1)
        
        # Navigasyon butonlarƒ±
        nav_frame = ttk.Frame(main_frame)
        nav_frame.grid(row=3, column=0, pady=(20, 0), sticky=(tk.W, tk.E))
        nav_frame.columnconfigure(0, weight=1)
        nav_frame.columnconfigure(1, weight=1)
        
        self.prev_button = ttk.Button(nav_frame, text="‚¨ÖÔ∏è √ñnceki", 
                                     command=self.previous_step, 
                                     style="Secondary.TButton",
                                     state="disabled")
        self.prev_button.grid(row=0, column=0, padx=(0, 10))
        
        self.next_button = ttk.Button(nav_frame, text="Sonraki ‚û°Ô∏è", 
                                    command=self.next_step, 
                                    style="Primary.TButton")
        self.next_button.grid(row=0, column=1, padx=(10, 0))
        
        # Log frame - her adƒ±mda g√∂r√ºn√ºr
        log_frame = ttk.LabelFrame(main_frame, text="üìã ƒ∞≈ülem Loglarƒ±", padding="20")
        log_frame.grid(row=4, column=0, sticky=(tk.W, tk.E), pady=(20, 0))
        log_frame.columnconfigure(0, weight=1)
        
        self.log_text = scrolledtext.ScrolledText(log_frame, height=8, width=80, 
                                                font=("Consolas", 9), 
                                                bg="#f8fafc", fg="#1e293b",
                                                insertbackground="#2563eb")
        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E))
        
        # Progress bar
        progress_frame = ttk.Frame(main_frame)
        progress_frame.grid(row=5, column=0, sticky=(tk.W, tk.E), pady=(10, 0))
        progress_frame.columnconfigure(0, weight=1)
        
        self.progress = ttk.Progressbar(progress_frame, mode='indeterminate', 
                                       style="Accent.Horizontal.TProgressbar")
        self.progress.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # Status bar
        self.status_bar = ttk.Label(progress_frame, text="Hazƒ±r", 
                                   font=("Segoe UI", 9), foreground="#64748b")
        self.status_bar.grid(row=1, column=0, sticky=tk.W)

    def show_step(self, step_number):
        """Belirtilen adƒ±mƒ± g√∂ster"""
        self.current_step = step_number
        
        # ƒ∞√ßerik frame'i temizle
        for widget in self.content_frame.winfo_children():
            widget.destroy()
        
        # Adƒ±m g√∂stergesini g√ºncelle
        step_names = [
            "Proje Bilgileri",
            "README.md Y√∂netimi", 
            "Git Durumu",
            "Branch Y√∂netimi",
            "Repository ƒ∞≈ülemleri"
        ]
        
        self.step_label.config(text=f"Adƒ±m {step_number + 1}/5: {step_names[step_number]}")
        self.step_progress['value'] = (step_number + 1) * 20
        
        # Navigasyon butonlarƒ±nƒ± g√ºncelle
        if step_number == 0:
            self.prev_button.config(state="disabled")
        else:
            self.prev_button.config(state="normal")
            
        if step_number == self.total_steps - 1:
            self.next_button.config(state="disabled")
        else:
            self.next_button.config(state="normal")
        
        # Adƒ±ma √∂zel i√ßeriƒüi g√∂ster
        if step_number == 0:
            self.show_project_info_step()
        elif step_number == 1:
            self.show_readme_step()
        elif step_number == 2:
            self.show_git_status_step()
        elif step_number == 3:
            self.show_branch_step()
        elif step_number == 4:
            self.show_repository_step()

    def show_project_info_step(self):
        """Adƒ±m 1: Proje bilgileri"""
        # Proje bilgileri frame
        project_frame = ttk.LabelFrame(self.content_frame, text="üìÅ Proje Bilgileri", padding="20")
        project_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 20))
        project_frame.columnconfigure(1, weight=1)
        
        # Proje klas√∂r√º se√ßimi
        folder_label = ttk.Label(project_frame, text="Proje Klas√∂r√º:", font=("Segoe UI", 10, "bold"))
        folder_label.grid(row=0, column=0, sticky=tk.W, padx=(0, 15), pady=(0, 8))
        
        self.project_path_var = tk.StringVar(value=self.current_directory)
        project_path_entry = ttk.Entry(project_frame, textvariable=self.project_path_var, 
                                     font=("Segoe UI", 10), width=45)
        project_path_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(0, 15), pady=(0, 8))
        
        browse_btn = ttk.Button(project_frame, text="üìÇ Klas√∂r Se√ß", 
                               command=self.browse_folder, style="Accent.TButton")
        browse_btn.grid(row=0, column=2, padx=(15, 0), pady=(0, 8))
        
        # Proje adƒ±
        name_label = ttk.Label(project_frame, text="Proje Adƒ±:", font=("Segoe UI", 10, "bold"))
        name_label.grid(row=1, column=0, sticky=tk.W, padx=(0, 15), pady=(0, 8))
        project_entry = ttk.Entry(project_frame, textvariable=self.project_name, 
                                font=("Segoe UI", 10), width=45)
        project_entry.grid(row=1, column=1, sticky=(tk.W, tk.E), padx=(0, 15), pady=(0, 8))
        
        # GitHub kullanƒ±cƒ± adƒ±
        user_label = ttk.Label(project_frame, text="GitHub Kullanƒ±cƒ±:", font=("Segoe UI", 10, "bold"))
        user_label.grid(row=2, column=0, sticky=tk.W, padx=(0, 15), pady=(0, 8))
        username_entry = ttk.Entry(project_frame, textvariable=self.github_username, 
                                 font=("Segoe UI", 10), width=45)
        username_entry.grid(row=2, column=1, sticky=(tk.W, tk.E), padx=(0, 15), pady=(0, 8))
        
        # Commit mesajƒ±
        commit_label = ttk.Label(project_frame, text="Commit Mesajƒ±:", font=("Segoe UI", 10, "bold"))
        commit_label.grid(row=3, column=0, sticky=tk.W, padx=(0, 15), pady=(0, 8))
        commit_entry = ttk.Entry(project_frame, textvariable=self.commit_message, 
                               font=("Segoe UI", 10), width=45)
        commit_entry.grid(row=3, column=1, sticky=(tk.W, tk.E), padx=(0, 15), pady=(0, 8))

    def show_readme_step(self):
        """Adƒ±m 2: README.md y√∂netimi"""
        readme_frame = ttk.LabelFrame(self.content_frame, text="üìñ README.md Y√∂netimi", padding="20")
        readme_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 20))
        readme_frame.columnconfigure(0, weight=1)
        
        # README se√ßenekleri
        readme_keep = ttk.Radiobutton(readme_frame, text="üìù Mevcut README.md'yi koru (√∂nerilen)", 
                                     variable=self.readme_var, value="keep")
        readme_keep.grid(row=0, column=0, sticky=tk.W, pady=(0, 15))
        
        readme_create = ttk.Radiobutton(readme_frame, text="üîÑ GitAuto ile yeni README.md olu≈ütur", 
                                       variable=self.readme_var, value="create")
        readme_create.grid(row=1, column=0, sticky=tk.W, pady=(0, 15))
        
        readme_view = ttk.Radiobutton(readme_frame, text="üëÅÔ∏è Mevcut README.md'yi g√∂r√ºnt√ºle", 
                                     variable=self.readme_var, value="view")
        readme_view.grid(row=2, column=0, sticky=tk.W, pady=(0, 15))
        
        # README √∂nizleme butonu
        preview_btn = ttk.Button(readme_frame, text="üëÅÔ∏è README √ñnizle", 
                                command=self.preview_readme, style="Secondary.TButton")
        preview_btn.grid(row=3, column=0, pady=(15, 0))
        
        # Repository durumu kontrol√º ve baƒülama butonu
        repo_status_frame = ttk.Frame(readme_frame)
        repo_status_frame.grid(row=4, column=0, sticky=(tk.W, tk.E), pady=(20, 0))
        repo_status_frame.columnconfigure(0, weight=1)
        
        # Repository durumu etiketi
        self.repo_status_readme_label = ttk.Label(repo_status_frame, 
                                                 text="Repository durumu kontrol ediliyor...", 
                                                 font=("Segoe UI", 10))
        self.repo_status_readme_label.grid(row=0, column=0, sticky=tk.W, pady=(0, 15))
        
        # Repository baƒülama butonu (sadece repository yoksa g√∂r√ºn√ºr)
        self.connect_button_readme = ttk.Button(repo_status_frame, text="üîó Repository Baƒüla", 
                                               command=self.connect_repository, style="Primary.TButton")
        self.connect_button_readme.grid(row=1, column=0, pady=(0, 15))
        
        # Repository durumunu kontrol et ve butonlarƒ± g√ºncelle
        self.update_readme_repo_status()

    def update_readme_repo_status(self):
        """README adƒ±mƒ±nda repository durumunu g√ºncelle"""
        try:
            # Widget'larƒ±n mevcut olup olmadƒ±ƒüƒ±nƒ± kontrol et
            if not hasattr(self, 'repo_status_readme_label') or not hasattr(self, 'connect_button_readme'):
                return  # Widget'lar hen√ºz olu≈üturulmamƒ±≈üsa √ßƒ±k
            
            # Widget'larƒ±n ger√ßekten mevcut olup olmadƒ±ƒüƒ±nƒ± kontrol et
            try:
                if not self.repo_status_readme_label.winfo_exists() or not self.connect_button_readme.winfo_exists():
                    return  # Widget'lar artƒ±k mevcut deƒüilse √ßƒ±k
            except tk.TclError:
                return  # Widget referans hatasƒ± durumunda √ßƒ±k
            
            # Repository durumunu ger√ßek zamanlƒ± kontrol et
            git_dir = os.path.join(self.current_directory, ".git")
            repo_exists = os.path.exists(git_dir) and os.path.isdir(git_dir)
            
            # Eƒüer .git klas√∂r√º varsa ama repository bozuksa
            if repo_exists:
                try:
                    # Git status komutu ile repository saƒülƒ±ƒüƒ±nƒ± kontrol et
                    result = subprocess.run("git status", shell=True, capture_output=True, 
                                          text=True, cwd=self.current_directory, timeout=5)
                    if result.returncode != 0:
                        repo_exists = False
                        self.log_message("‚ö†Ô∏è README: Git repository bozuk veya ge√ßersiz")
                except:
                    repo_exists = False
                    self.log_message("‚ö†Ô∏è README: Git repository eri≈üilemez durumda")
            
            if repo_exists:
                # Repository varsa
                try:
                    self.repo_status_readme_label.config(text="‚úÖ Git repository mevcut ve saƒülƒ±klƒ±", foreground="green")
                    self.connect_button_readme.grid_remove()  # Butonu gizle
                    self.log_message("‚úÖ README: Repository mevcut - Baƒülama butonu gizlendi")
                except tk.TclError:
                    # Widget referans hatasƒ± durumunda sadece log'a yaz
                    self.log_message("‚ö†Ô∏è README widget'larƒ± g√ºncellenirken referans hatasƒ±")
            else:
                # Repository yoksa
                try:
                    self.repo_status_readme_label.config(text="‚ùå Git repository bulunamadƒ±", foreground="red")
                    self.connect_button_readme.grid()  # Butonu g√∂ster
                    self.log_message("‚ùå README: Repository bulunamadƒ± - Baƒülama butonu g√∂sterildi")
                except tk.TclError:
                    # Widget referans hatasƒ± durumunda sadece log'a yaz
                    self.log_message("‚ö†Ô∏è README widget'larƒ± g√ºncellenirken referans hatasƒ±")
                
        except Exception as e:
            # Widget mevcutsa hata mesajƒ±nƒ± g√∂ster
            try:
                if hasattr(self, 'repo_status_readme_label') and self.repo_status_readme_label.winfo_exists():
                    self.repo_status_readme_label.config(text="‚ùå Repository durumu kontrol edilemedi", foreground="red")
            except tk.TclError:
                pass  # Widget referans hatasƒ± durumunda sessizce devam et
            self.log_message(f"‚ùå Repository durum kontrol√º hatasƒ±: {e}")

    def check_repository_before_proceed(self):
        """README adƒ±mƒ±ndan sonra repository kontrol√º yap"""
        repo_exists = os.path.exists(os.path.join(self.current_directory, ".git"))
        
        if not repo_exists:
            result = messagebox.askyesno(
                "Repository Gerekli", 
                "‚ùå Git repository hen√ºz ba≈ülatƒ±lmamƒ±≈ü!\n\n"
                "Devam etmek i√ßin √∂nce 'Repository Baƒüla' butonunu kullanarak\n"
                "bir Git repository olu≈üturmanƒ±z gerekiyor.\n\n"
                "Repository olu≈üturmak ister misiniz?"
            )
            
            if result:
                # README adƒ±mƒ±na geri d√∂n
                self.show_step(1)
                return False
            else:
                return False
        
        return True

    def show_branch_step(self):
        """Adƒ±m 3: Branch y√∂netimi"""
        branch_frame = ttk.LabelFrame(self.content_frame, text="üåø Branch Y√∂netimi", padding="20")
        branch_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 20))
        branch_frame.columnconfigure(1, weight=1)
        
        # Branch se√ßimi
        branch_label = ttk.Label(branch_frame, text="Hedef Branch:", font=("Segoe UI", 10, "bold"))
        branch_label.grid(row=0, column=0, sticky=tk.W, padx=(0, 15), pady=(0, 8))
        
        self.branch_combo = ttk.Combobox(branch_frame, textvariable=self.selected_branch, 
                                        values=["main", "master", "develop"], width=25, 
                                        state="readonly", font=("Segoe UI", 10))
        self.branch_combo.grid(row=0, column=1, sticky=tk.W, padx=(0, 15), pady=(0, 8))
        
        refresh_btn = ttk.Button(branch_frame, text="üîÑ", command=self.refresh_branches, 
                                width=4, style="Accent.TButton")
        refresh_btn.grid(row=0, column=2, padx=(15, 0), pady=(0, 8))
        
        # Yeni branch olu≈ütur
        new_branch_label = ttk.Label(branch_frame, text="Yeni Branch:", font=("Segoe UI", 10, "bold"))
        new_branch_label.grid(row=1, column=0, sticky=tk.W, padx=(0, 15), pady=(0, 8))
        
        self.new_branch_var = tk.StringVar()
        new_branch_entry = ttk.Entry(branch_frame, textvariable=self.new_branch_var, 
                                   width=25, font=("Segoe UI", 10))
        new_branch_entry.grid(row=1, column=1, sticky=tk.W, padx=(0, 15), pady=(0, 8))
        
        create_branch_btn = ttk.Button(branch_frame, text="üå± Branch Olu≈ütur", 
                                      command=self.create_new_branch, style="Accent.TButton")
        create_branch_btn.grid(row=1, column=2, padx=(15, 0), pady=(0, 8))
        
        # Branch i≈ülemleri
        button_frame = ttk.Frame(branch_frame)
        button_frame.grid(row=2, column=0, columnspan=3, pady=(15, 0))
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        
        list_branches_btn = ttk.Button(button_frame, text="üìã Branch'leri Listele", 
                                      command=self.list_branches, style="Secondary.TButton")
        list_branches_btn.grid(row=0, column=0, padx=(0, 10))
        
        clean_btn = ttk.Button(button_frame, text="üßπ Repository Temizle", 
                              command=self.clean_repository, style="Secondary.TButton")
        clean_btn.grid(row=0, column=1, padx=(10, 0))
        
        # Branch listesini g√ºncelle
        self.refresh_branches()

    def show_git_status_step(self):
        """Adƒ±m 4: Git durumu"""
        status_frame = ttk.LabelFrame(self.content_frame, text="üîç Git Durumu", padding="20")
        status_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 20))
        status_frame.columnconfigure(1, weight=1)
        
        # Git durum etiketleri
        self.git_status_label = ttk.Label(status_frame, text="Git durumu kontrol ediliyor...", 
                                         font=("Segoe UI", 10))
        self.git_status_label.grid(row=0, column=0, columnspan=2, sticky=tk.W, pady=(0, 8))
        
        self.repo_status_label = ttk.Label(status_frame, text="Repository durumu kontrol ediliyor...", 
                                          font=("Segoe UI", 10))
        self.repo_status_label.grid(row=1, column=0, columnspan=2, sticky=tk.W, pady=(0, 8))
        
        # Git kurulum kontrol√º
        git_check_btn = ttk.Button(status_frame, text="üîç Git Durumunu Kontrol Et", 
                                  command=self.check_git_status, style="Accent.TButton")
        git_check_btn.grid(row=2, column=0, columnspan=2, pady=(15, 0))

    def show_repository_step(self):
        """Adƒ±m 5: Repository i≈ülemleri"""
        repo_frame = ttk.LabelFrame(self.content_frame, text="üöÄ Repository Yayƒ±nlama", padding="20")
        repo_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 20))
        repo_frame.columnconfigure(0, weight=1)
        
        # Ana i≈ülem butonu - Adƒ±m 5'te direkt aktif
        self.main_button = ttk.Button(repo_frame, text="üöÄ Repository'yi Yayƒ±nla", 
                                      command=self.start_publication, style="Primary.TButton",
                                      state="normal")
        self.main_button.grid(row=0, column=0, pady=(0, 15))
        
        # Bilgi etiketi
        info_label = ttk.Label(repo_frame, 
                              text="üí° Repository baƒülama i≈ülemi README.md adƒ±mƒ±nda yapƒ±lmƒ±≈ütƒ±r.\nüöÄ Yayƒ±nlama butonu aktif - Dosyalarƒ± yayƒ±nlayabilirsiniz!",
                              font=("Segoe UI", 10),
                              foreground="#64748b",
                              justify="center")
        info_label.grid(row=1, column=0, pady=(15, 0))

    def next_step(self):
        """Sonraki adƒ±ma ge√ß"""
        # Adƒ±m 1 (Proje Bilgileri) bitince repository kontrol√º yap
        if self.current_step == 0:  # Proje Bilgileri adƒ±mƒ±ndan sonra
            self.log_message("üîç Adƒ±m 1 tamamlandƒ± - Repository durumu kontrol ediliyor...")
            self.check_repository_status()
            
            # Repository durumuna g√∂re UI'ƒ± g√ºncelle
            self.refresh_ui_after_repo_check()
        
        # README adƒ±mƒ±ndan sonra repository kontrol√º yap
        elif self.current_step == 1:  # README adƒ±mƒ±ndan sonra
            if not self.check_repository_before_proceed():
                return
        
        if self.current_step < self.total_steps - 1:
            self.show_step(self.current_step + 1)

    def previous_step(self):
        """√ñnceki adƒ±ma ge√ß"""
        if self.current_step > 0:
            self.show_step(self.current_step - 1)



    def preview_readme(self):
        """README.md √∂nizlemesi g√∂ster"""
        readme_path = os.path.join(self.current_directory, "README.md")
        if os.path.exists(readme_path):
            try:
                with open(readme_path, "r", encoding="utf-8") as f:
                    content = f.read()
                
                # √ñnizleme penceresi
                preview_window = tk.Toplevel(self.root)
                preview_window.title("README.md √ñnizleme")
                preview_window.geometry("600x400")
                preview_window.configure(bg="#ffffff")
                
                # ƒ∞√ßerik
                text_widget = scrolledtext.ScrolledText(preview_window, 
                                                      font=("Consolas", 10),
                                                      bg="#f8fafc", fg="#1e293b")
                text_widget.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
                text_widget.insert(tk.END, content)
                text_widget.config(state=tk.DISABLED)
                
            except Exception as e:
                messagebox.showerror("Hata", f"README.md okunamadƒ±:\n{e}")
        else:
            messagebox.showinfo("Bilgi", "README.md dosyasƒ± bulunamadƒ±.")

    def check_git_status(self):
        """Git durumunu kontrol et - ger√ßek zamanlƒ±"""
        try:
            # Git kurulum kontrol√º
            result = subprocess.run("git --version", shell=True, capture_output=True, text=True)
            self.git_installed = result.returncode == 0
            
            # Git durumu etiketini g√ºncelle (eƒüer varsa)
            if hasattr(self, 'git_status_label'):
                try:
                    if self.git_status_label.winfo_exists():
                        if self.git_installed:
                            self.git_status_label.config(text="‚úÖ Git kurulu ve hazƒ±r", foreground="green")
                        else:
                            self.git_status_label.config(text="‚ùå Git kurulu deƒüil", foreground="red")
                except tk.TclError:
                    pass  # Widget referans hatasƒ± durumunda sessizce devam et
            
            # Repository kontrol√º - ger√ßek zamanlƒ±
            git_dir = os.path.join(self.current_directory, ".git")
            self.git_repo_exists = os.path.exists(git_dir) and os.path.isdir(git_dir)
            
            # Eƒüer .git klas√∂r√º varsa ama bo≈üsa (bozuk repository)
            if os.path.exists(git_dir) and os.path.isdir(git_dir):
                try:
                    # Git status komutu ile repository saƒülƒ±ƒüƒ±nƒ± kontrol et
                    result = subprocess.run("git status", shell=True, capture_output=True, 
                                          text=True, cwd=self.current_directory, timeout=5)
                    if result.returncode != 0:
                        self.git_repo_exists = False
                        self.log_message("‚ö†Ô∏è Git repository bozuk veya ge√ßersiz")
                except:
                    self.git_repo_exists = False
                    self.log_message("‚ö†Ô∏è Git repository eri≈üilemez durumda")
            
            # Repository durumu etiketini g√ºncelle (eƒüer varsa)
            if hasattr(self, 'repo_status_label'):
                try:
                    if self.repo_status_label.winfo_exists():
                        if self.git_repo_exists:
                            self.repo_status_label.config(text="‚úÖ Git repository mevcut", foreground="green")
                        else:
                            self.repo_status_label.config(text="‚ùå Git repository bulunamadƒ±", foreground="red")
                except tk.TclError:
                    pass  # Widget referans hatasƒ± durumunda sessizce devam et
            
            # Yayƒ±n butonu durumunu g√ºncelle
            if self.git_repo_exists:
                # Eƒüer repository zaten mevcutsa yayƒ±n butonunu aktif hale getir
                if hasattr(self, 'main_button'):
                    try:
                        if self.main_button.winfo_exists():
                            self.root.after(0, lambda: self.main_button.config(state="normal"))
                    except tk.TclError:
                        pass  # Widget referans hatasƒ± durumunda sessizce devam et
                        
                self.log_message("‚úÖ Repository mevcut - Yayƒ±nlama aktif")
            else:
                # Repository yoksa yayƒ±n butonunu devre dƒ±≈üƒ± bƒ±rak
                if hasattr(self, 'main_button'):
                    try:
                        if self.main_button.winfo_exists():
                            self.root.after(0, lambda: self.main_button.config(state="disabled"))
                    except tk.TclError:
                        pass  # Widget referans hatasƒ± durumunda sessizce devam et
                        
                self.log_message("‚ùå Repository bulunamadƒ± - Yayƒ±nlama devre dƒ±≈üƒ±")
            
            # README adƒ±mƒ±ndaki repository durumunu g√ºncelle (eƒüer varsa)
            if hasattr(self, 'update_readme_repo_status'):
                try:
                    self.update_readme_repo_status()
                except Exception as e:
                    # Hata durumunda sadece log'a yaz, uygulamayƒ± durdurma
                    self.log_message(f"‚ö†Ô∏è README repository durumu g√ºncellenirken hata: {e}")
                    
        except Exception as e:
            self.log_message(f"‚ùå Git durum kontrol√º hatasƒ±: {e}")

    def log_message(self, message):
        """Log mesajƒ± ekle"""
        self.log_queue.put(message)

    def update_log(self):
        """Log mesajlarƒ±nƒ± g√ºncelle"""
        try:
            while True:
                message = self.log_queue.get_nowait()
                self.log_text.insert(tk.END, f"{message}\n")
                self.log_text.see(tk.END)
        except queue.Empty:
            pass
        
        # Her 100ms'de bir kontrol et
        self.root.after(100, self.update_log)

    def browse_folder(self):
        """Kullanƒ±cƒ±nƒ±n klas√∂r se√ßmesini saƒülar"""
        folder_selected = filedialog.askdirectory()
        if folder_selected:
            self.project_path_var.set(folder_selected)
            self.current_directory = folder_selected
            
            # Proje adƒ±nƒ± otomatik √∂ner
            folder_name = os.path.basename(folder_selected)
            if not self.project_name.get().strip():
                self.project_name.set(folder_name)
            
            self.log_message(f"üìÅ Proje klas√∂r√º se√ßildi: {folder_selected}")
            
            # Repository durumunu kontrol et
            self.check_repository_status()
            
            # Git durumunu yeni klas√∂r i√ßin g√ºncelle
            self.check_git_status()
            
            # UI'ƒ± repository durumuna g√∂re g√ºncelle
            self.refresh_ui_after_folder_change()
            
            # README adƒ±mƒ±ndaki repository durumunu g√ºncelle (eƒüer o adƒ±mdaysak)
            if hasattr(self, 'update_readme_repo_status'):
                try:
                    self.update_readme_repo_status()
                except Exception as e:
                    # Hata durumunda sadece log'a yaz, uygulamayƒ± durdurma
                    self.log_message(f"‚ö†Ô∏è README repository durumu g√ºncellenirken hata: {e}")
            
            # Klas√∂rdeki dosyalarƒ± listele
            self.list_folder_contents()

    def check_repository_status(self):
        """Repository durumunu kontrol et ve log'a yaz"""
        try:
            if not self.current_directory:
                return
                
            git_dir = os.path.join(self.current_directory, ".git")
            if os.path.exists(git_dir):
                # Git repository mevcut
                self.log_message("üîç Repository durumu kontrol ediliyor...")
                
                # Git status kontrol et
                try:
                    result = subprocess.run("git status --porcelain", shell=True, 
                                          capture_output=True, text=True, cwd=self.current_directory, timeout=10)
                    if result.returncode == 0:
                        if result.stdout.strip():
                            self.log_message("üìù Repository'de deƒüi≈üiklikler mevcut")
                        else:
                            self.log_message("‚úÖ Repository temiz (deƒüi≈üiklik yok)")
                    else:
                        self.log_message("‚ö†Ô∏è Git status kontrol edilemedi")
                except Exception as e:
                    self.log_message(f"‚ö†Ô∏è Git status hatasƒ±: {e}")
                
                # Remote origin kontrol et
                try:
                    result = subprocess.run("git remote -v", shell=True, 
                                          capture_output=True, text=True, cwd=self.current_directory, timeout=10)
                    if result.returncode == 0 and result.stdout.strip():
                        self.log_message("üîó Remote origin baƒülƒ±")
                    else:
                        self.log_message("‚ö†Ô∏è Remote origin bulunamadƒ±")
                except Exception as e:
                    self.log_message(f"‚ö†Ô∏è Remote kontrol hatasƒ±: {e}")
                
                # Branch bilgisi
                try:
                    result = subprocess.run("git branch --show-current", shell=True, 
                                          capture_output=True, text=True, cwd=self.current_directory, timeout=10)
                    if result.returncode == 0:
                        current_branch = result.stdout.strip()
                        self.log_message(f"üåø Aktif branch: {current_branch}")
                    else:
                        self.log_message("‚ö†Ô∏è Aktif branch bilgisi alƒ±namadƒ±")
                except Exception as e:
                    self.log_message(f"‚ö†Ô∏è Branch kontrol hatasƒ±: {e}")
                    
            else:
                # Git repository yok
                self.log_message("‚ùå Bu klas√∂rde Git repository bulunamadƒ±")
                self.log_message("üí° Repository baƒülamak i√ßin 'Repository Baƒüla' butonunu kullanƒ±n")
                
        except Exception as e:
            self.log_message(f"‚ö†Ô∏è Repository durumu kontrol edilirken hata: {e}")

    def refresh_ui_after_repo_check(self):
        """Repository kontrol√ºnden sonra UI'ƒ± g√ºncelle"""
        try:
            if not self.current_directory:
                return
                
            git_dir = os.path.join(self.current_directory, ".git")
            repo_exists = os.path.exists(git_dir)
            
            if repo_exists:
                self.log_message("üîÑ Repository mevcut - UI g√ºncelleniyor...")
                
                # Repository bilgilerini al
                try:
                    # Aktif branch
                    result = subprocess.run("git branch --show-current", shell=True, 
                                          capture_output=True, text=True, cwd=self.current_directory, timeout=10)
                    current_branch = result.stdout.strip() if result.returncode == 0 else "main"
                    
                    # Remote origin
                    result = subprocess.run("git remote get-url origin", shell=True, 
                                          capture_output=True, text=True, cwd=self.current_directory, timeout=10)
                    remote_url = result.stdout.strip() if result.returncode == 0 else "Bilinmiyor"
                    
                    # Commit sayƒ±sƒ±
                    result = subprocess.run("git rev-list --count HEAD", shell=True, 
                                          capture_output=True, text=True, cwd=self.current_directory, timeout=10)
                    commit_count = result.stdout.strip() if result.returncode == 0 else "0"
                    
                    self.log_message(f"üìä Repository Bilgileri:")
                    self.log_message(f"  üåø Aktif Branch: {current_branch}")
                    self.log_message(f"  üîó Remote: {remote_url}")
                    self.log_message(f"  üíæ Commit Sayƒ±sƒ±: {commit_count}")
                    
                except Exception as e:
                    self.log_message(f"‚ö†Ô∏è Repository bilgileri alƒ±namadƒ±: {e}")
                
                # UI g√ºncellemeleri
                self.log_message("‚úÖ UI g√ºncellemeleri tamamlandƒ±")
                
            else:
                self.log_message("üÜï Repository bulunamadƒ± - Yeni repository olu≈üturulabilir")
                self.log_message("üí° Repository baƒülamak i√ßin README adƒ±mƒ±nda 'Repository Baƒüla' butonunu kullanƒ±n")
                
        except Exception as e:
            self.log_message(f"‚ö†Ô∏è UI g√ºncellenirken hata: {e}")

    def refresh_ui_after_folder_change(self):
        """Klas√∂r deƒüi≈üikliƒüi sonrasƒ± UI'ƒ± g√ºncelle"""
        try:
            self.log_message("üîÑ Klas√∂r deƒüi≈üikliƒüi - UI g√ºncelleniyor...")
            
            # Repository durumunu kontrol et
            git_dir = os.path.join(self.current_directory, ".git")
            repo_exists = os.path.exists(git_dir) and os.path.isdir(git_dir)
            
            # Repository saƒülƒ±ƒüƒ±nƒ± kontrol et
            if repo_exists:
                try:
                    result = subprocess.run("git status", shell=True, capture_output=True, 
                                          text=True, cwd=self.current_directory, timeout=5)
                    if result.returncode != 0:
                        repo_exists = False
                        self.log_message("‚ö†Ô∏è Repository bozuk - UI g√ºncelleniyor")
                except:
                    repo_exists = False
                    self.log_message("‚ö†Ô∏è Repository eri≈üilemez - UI g√ºncelleniyor")
            
            # T√ºm UI bile≈üenlerini g√ºncelle
            if repo_exists:
                self.log_message("‚úÖ Repository mevcut - T√ºm UI bile≈üenleri g√ºncelleniyor")
                
                # Yayƒ±n butonunu aktif hale getir
                if hasattr(self, 'main_button'):
                    try:
                        if self.main_button.winfo_exists():
                            self.main_button.config(state="normal")
                    except tk.TclError:
                        pass
                
                # README durumunu g√ºncelle
                self.update_readme_repo_status()
                
            else:
                self.log_message("‚ùå Repository bulunamadƒ± - UI devre dƒ±≈üƒ± bƒ±rakƒ±lƒ±yor")
                
                # Yayƒ±n butonunu devre dƒ±≈üƒ± bƒ±rak
                if hasattr(self, 'main_button'):
                    try:
                        if self.main_button.winfo_exists():
                            self.main_button.config(state="disabled")
                    except tk.TclError:
                        pass
                
                # README durumunu g√ºncelle
                self.update_readme_repo_status()
            
            self.log_message("‚úÖ UI g√ºncelleme tamamlandƒ±")
            
        except Exception as e:
            self.log_message(f"‚ö†Ô∏è UI g√ºncelleme hatasƒ±: {e}")

    def validate_inputs(self):
        """Kullanƒ±cƒ± giri≈ülerini doƒürula"""
        project_name = self.project_name.get().strip()
        github_username = self.github_username.get().strip()
        
        if not project_name:
            messagebox.showerror("Hata", "Proje adƒ± bo≈ü olamaz!")
            return False
        
        if not github_username:
            messagebox.showerror("Hata", "GitHub kullanƒ±cƒ± adƒ± bo≈ü olamaz!")
            return False
        
        # Ge√ßersiz karakterleri kontrol et
        invalid_chars = [' ', '/', '\\', ':', '*', '?', '"', '<', '>', '|', '@', '{', '}']
        if any(char in project_name for char in invalid_chars):
            messagebox.showerror("Hata", f"Proje adƒ±nda ge√ßersiz karakterler var!\nGe√ßersiz: {' '.join(invalid_chars)}")
            return False
        
        if any(char in github_username for char in invalid_chars):
            messagebox.showerror("Hata", f"GitHub kullanƒ±cƒ± adƒ±nda ge√ßersiz karakterler var!\nGe√ßersiz: {' '.join(invalid_chars)}")
            return False
        
        if not os.path.exists(self.current_directory):
            messagebox.showerror("Hata", "Proje klas√∂r√º bulunamadƒ±!\nL√ºtfen ge√ßerli bir klas√∂r se√ßin.")
            return False
        
        return True

    def connect_repository(self):
        """Repository baƒülama - bo≈ü repo olu≈ütur ve first commit at"""
        if not self.validate_inputs():
            return
            
        # Onay dialog'u g√∂ster
        result = messagebox.askyesno(
            "Repository Baƒüla",
            f"üîó GitHub'da '{self.project_name.get()}' repository'si olu≈üturulacak ve baƒülanacak.\n\n"
            f"üìÅ Klas√∂r: {self.current_directory}\n"
            f"üë§ Kullanƒ±cƒ±: {self.github_username.get()}\n"
            f"üìù ƒ∞lk commit: {self.commit_message.get()}\n\n"
            "Devam etmek istiyor musunuz?"
        )
        
        if result:
            self.log_message("üîó Repository baƒülama i≈ülemi ba≈ülƒ±yor...")
            
            # README adƒ±mƒ±ndaki butonu devre dƒ±≈üƒ± bƒ±rak (eƒüer varsa)
            if hasattr(self, 'connect_button_readme'):
                try:
                    if self.connect_button_readme.winfo_exists():
                        self.connect_button_readme.config(state='disabled')
                except tk.TclError:
                    pass  # Widget referans hatasƒ± durumunda sessizce devam et
            
            # Yayƒ±n butonunu devre dƒ±≈üƒ± bƒ±rak (eƒüer varsa)
            if hasattr(self, 'main_button'):
                try:
                    if self.main_button.winfo_exists():
                        self.main_button.config(state='disabled')
                except tk.TclError:
                    pass  # Widget referans hatasƒ± durumunda sessizce devam et
            
            self.progress.start()
            
            # Repository baƒülama i≈ülemini thread'de √ßalƒ±≈ütƒ±r
            threading.Thread(target=self.connect_repository_worker, daemon=True).start()
    
    def connect_repository_worker(self):
        """Repository baƒülama i≈ülemi - arka planda √ßalƒ±≈üƒ±r"""
        try:
            original_dir = os.getcwd()
            os.chdir(self.current_directory)
            
            # 1. Git init
            self.log_message("üîß Git repository ba≈ülatƒ±lƒ±yor...")
            result = subprocess.run("git init", shell=True, capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                raise Exception(f"Git init hatasƒ±: {result.stderr}")
            self.log_message("‚úÖ Git repository ba≈ülatƒ±ldƒ±")
            
            # 2. README.md olu≈ütur (eƒüer yoksa)
            if self.readme_var.get() == "create":
                readme_path = os.path.join(self.current_directory, "README.md")
                if not os.path.exists(readme_path):
                    self.log_message("üìù README.md olu≈üturuluyor...")
                    readme_content = f"# {self.project_name.get()}\n\nBu proje GitAuto ile otomatik olarak olu≈üturuldu.\n"
                    with open(readme_path, "w", encoding="utf-8") as f:
                        f.write(readme_content)
                    self.log_message("‚úÖ README.md olu≈üturuldu")
            
            # 3. B√ºy√ºk dosyalarƒ± kontrol et ve filtrele
            self.log_message("üîç B√ºy√ºk dosyalar kontrol ediliyor...")
            self.detect_and_filter_large_files()
            
            # 4. √ñnce t√ºm dosyalarƒ± cache'den kaldƒ±r ve temizle
            self.log_message("üßπ Git cache temizleniyor...")
            try:
                # T√ºm dosyalarƒ± cache'den kaldƒ±r
                subprocess.run("git rm -r --cached .", shell=True, capture_output=True, text=True, timeout=30)
                self.log_message("‚úÖ Git cache temizlendi")
                
                # .gitignore'ƒ± g√ºncelle
                self.update_gitignore_for_large_files()
                
                # Sadece gerekli dosyalarƒ± ekle (node_modules hari√ß)
                self.log_message("üìÅ Sadece gerekli dosyalar ekleniyor...")
                
                # √ñnce .gitignore'ƒ± ekle
                subprocess.run("git add .gitignore", shell=True, capture_output=True, text=True, timeout=10)
                
                # Sonra diƒüer dosyalarƒ± ekle (node_modules hari√ß)
                result = subprocess.run("git add .", shell=True, capture_output=True, text=True, timeout=60)
            except Exception as e:
                self.log_message(f"‚ö†Ô∏è Cache temizliƒüi sƒ±rasƒ±nda hata: {e}")
                # Normal git add yap
                result = subprocess.run("git add .", shell=True, capture_output=True, text=True, timeout=60)
            
            if result.returncode != 0:
                raise Exception(f"Git add hatasƒ±: {result.stderr}")
            self.log_message("‚úÖ Dosyalar eklendi")
            
            # 4. Git commit (konfig√ºrasyon kontrol√º ile)
            commit_msg = self.commit_message.get().strip() or "first commit"
            self.log_message(f"üíæ ƒ∞lk commit yapƒ±lƒ±yor: {commit_msg}")
            
            # Git konfig√ºrasyonunu kontrol et ve ayarla
            self.log_message("‚öôÔ∏è Git konfig√ºrasyonu kontrol ediliyor...")
            
            # User name kontrol et
            user_result = subprocess.run("git config user.name", shell=True, capture_output=True, text=True, timeout=5)
            if user_result.returncode != 0 or not user_result.stdout.strip():
                self.log_message("üë§ Git user.name ayarlanƒ±yor...")
                subprocess.run(f'git config user.name "{self.github_username.get()}"', shell=True, capture_output=True, text=True, timeout=5)
            
            # User email kontrol et
            email_result = subprocess.run("git config user.email", shell=True, capture_output=True, text=True, timeout=5)
            if email_result.returncode != 0 or not email_result.stdout.strip():
                self.log_message("üìß Git user.email ayarlanƒ±yor...")
                subprocess.run(f'git config user.email "{self.github_username.get()}@users.noreply.github.com"', shell=True, capture_output=True, text=True, timeout=5)
            
            # Commit yap
            result = subprocess.run(f'git commit -m "{commit_msg}"', shell=True, capture_output=True, text=True, timeout=15)
            if result.returncode != 0:
                error_msg = result.stderr.strip() if result.stderr else "Bilinmeyen commit hatasƒ±"
                self.log_message(f"‚ö†Ô∏è Commit hatasƒ±: {error_msg}")
                
                # Alternatif commit y√∂ntemi dene
                self.log_message("üîÑ Alternatif commit y√∂ntemi deneniyor...")
                result = subprocess.run(f'git commit -m "{commit_msg}" --allow-empty', shell=True, capture_output=True, text=True, timeout=15)
                if result.returncode != 0:
                    raise Exception(f"Git commit hatasƒ±: {result.stderr}")
            
            self.log_message("‚úÖ ƒ∞lk commit tamamlandƒ±")
            
            # 5. Branch ayarla
            target_branch = self.selected_branch.get() or "main"
            self.log_message(f"üåø Branch '{target_branch}' ayarlanƒ±yor...")
            result = subprocess.run(f"git branch -M {target_branch}", shell=True, capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                self.log_message(f"‚ö†Ô∏è Branch ayarlama uyarƒ±sƒ±: {result.stderr}")
            else:
                self.log_message(f"‚úÖ Branch '{target_branch}' ayarlandƒ±")
            
            # 6. Remote ekle
            repo_url = f"https://github.com/{self.github_username.get()}/{self.project_name.get()}.git"
            self.log_message(f"üîó Remote repository baƒülanƒ±yor: {repo_url}")
            result = subprocess.run(f'git remote add origin "{repo_url}"', shell=True, capture_output=True, text=True, timeout=10)
            if result.returncode != 0 and "already exists" not in result.stderr:
                raise Exception(f"Remote add hatasƒ±: {result.stderr}")
            self.log_message("‚úÖ Remote repository baƒülandƒ±")
            
            # 7. Push
            self.log_message(f"üöÄ GitHub'a yayƒ±nlanƒ±yor...")
            self.log_message("‚è≥ Bu i≈ülem b√ºy√ºk projelerde biraz zaman alabilir...")
            result = subprocess.run(f"git push -u origin {target_branch}", shell=True, capture_output=True, text=True, timeout=120)
            if result.returncode != 0:
                raise Exception(f"Push hatasƒ±: {result.stderr}")
            self.log_message("‚úÖ Repository GitHub'a yayƒ±nlandƒ±!")
            
            os.chdir(original_dir)
            
            # Ba≈üarƒ± mesajƒ±
            self.root.after(0, lambda: messagebox.showinfo(
                "Ba≈üarƒ±lƒ±! üéâ",
                f"üîó Repository ba≈üarƒ±yla baƒülandƒ±!\n\n"
                f"üìç URL: https://github.com/{self.github_username.get()}/{self.project_name.get()}\n"
                f"üåø Branch: {target_branch}\n\n"
                "Artƒ±k branch i≈ülemleri yapabilir ve yayƒ±nlama yapabilirsiniz!"
            ))
            
            # Yayƒ±n butonunu aktif hale getir
            self.root.after(0, lambda: self.main_button.config(state="normal"))
             
            # README adƒ±mƒ±ndaki repository durumunu g√ºncelle
            self.root.after(0, self.update_readme_repo_status)
            
            # Branch listesini g√ºncelle
            self.root.after(100, self.refresh_branches)
            
        except Exception as e:
            os.chdir(original_dir)
            error_msg = str(e)  # Hata mesajƒ±nƒ± string olarak sakla
            self.log_message(f"‚ùå Repository baƒülama hatasƒ±: {error_msg}")
            self.root.after(0, lambda: messagebox.showerror("Hata", f"Repository baƒülama hatasƒ±:\n{error_msg}"))
        
        finally:
            self.root.after(0, self.repository_connect_finished)
    
    def repository_connect_finished(self):
        """Repository baƒülama i≈ülemi tamamlandƒ±"""
        # README adƒ±mƒ±ndaki butonu aktif hale getir (eƒüer varsa)
        if hasattr(self, 'connect_button_readme'):
            try:
                if self.connect_button_readme.winfo_exists():
                    self.connect_button_readme.config(state='normal')
            except tk.TclError:
                pass  # Widget referans hatasƒ± durumunda sessizce devam et
        
        # Repository baƒülandƒ±ktan sonra yayƒ±n butonunu aktif hale getir
        if hasattr(self, 'main_button'):
            try:
                if self.main_button.winfo_exists():
                    self.main_button.config(state='normal')
            except tk.TclError:
                pass  # Widget referans hatasƒ± durumunda sessizce devam et
        
        self.progress.stop()
        self.check_git_status()

    def refresh_branches(self):
        """Ger√ßek branch'leri listele ve combo box'ƒ± g√ºncelle"""
        try:
            # branch_combo hen√ºz olu≈üturulmamƒ±≈üsa bekle
            if not hasattr(self, 'branch_combo'):
                return
                
            if not os.path.exists(os.path.join(self.current_directory, ".git")):
                self.branch_combo['values'] = ["main", "master", "develop"]
                self.log_message("‚ÑπÔ∏è Git repository hen√ºz ba≈ülatƒ±lmamƒ±≈ü - varsayƒ±lan branch'ler g√∂steriliyor")
                return
            
            original_dir = os.getcwd()
            os.chdir(self.current_directory)
            
            # Local branch'leri al
            result = subprocess.run("git branch", shell=True, capture_output=True, text=True, timeout=10)
            local_branches = []
            
            if result.returncode == 0 and result.stdout:
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        branch = line.strip().replace('*', '').strip()
                        if branch and not branch.startswith('('):
                            local_branches.append(branch)
            
            # Remote branch'leri al
            result = subprocess.run("git branch -r", shell=True, capture_output=True, text=True, timeout=10)
            remote_branches = []
            
            if result.returncode == 0 and result.stdout:
                for line in result.stdout.strip().split('\n'):
                    if line.strip() and 'origin/' in line:
                        branch = line.strip().replace('origin/', '').strip()
                        if branch and branch != 'HEAD' and not branch.startswith('('):
                            remote_branches.append(branch)
            
            # T√ºm branch'leri birle≈ütir ve tekrarlarƒ± kaldƒ±r
            all_branches = list(set(local_branches + remote_branches))
            
            # Varsayƒ±lan branch'leri ekle
            default_branches = ["main", "master", "develop"]
            for branch in default_branches:
                if branch not in all_branches:
                    all_branches.append(branch)
            
            # Sƒ±rala
            all_branches.sort()
            
            # Combo box'ƒ± g√ºncelle
            self.branch_combo['values'] = all_branches
            
            # Mevcut branch'ƒ± se√ß
            current_result = subprocess.run("git branch --show-current", shell=True, capture_output=True, text=True, timeout=5)
            if current_result.returncode == 0 and current_result.stdout.strip():
                current_branch = current_result.stdout.strip()
                if current_branch in all_branches:
                    self.selected_branch.set(current_branch)
                    self.log_message(f"üåø Aktif branch: {current_branch}")
            
            self.log_message(f"üîÑ Branch listesi g√ºncellendi: {len(all_branches)} branch bulundu")
            
            os.chdir(original_dir)
            
        except Exception as e:
            self.log_message(f"‚ö†Ô∏è Branch listesi g√ºncellenirken hata: {e}")
            self.branch_combo['values'] = ["main", "master", "develop"]

    def clean_repository(self):
        """Repository'yi temizle - gereksiz dosyalarƒ± kaldƒ±r"""
        try:
            if not os.path.exists(os.path.join(self.current_directory, ".git")):
                messagebox.showerror("Hata", "Git repository bulunamadƒ±!")
                return
            
            # Onay al
            result = messagebox.askyesno(
                "Repository Temizle",
                "üßπ Repository temizlenecek:\n\n"
                "‚Ä¢ Gereksiz dosyalar kaldƒ±rƒ±lacak\n"
                "‚Ä¢ .gitignore g√ºncellenecek\n"
                "‚Ä¢ Git cache temizlenecek\n\n"
                "Devam etmek istiyor musunuz?"
            )
            
            if result:
                self.log_message("üßπ Repository temizleme ba≈ülatƒ±lƒ±yor...")
                
                original_dir = os.getcwd()
                os.chdir(self.current_directory)
                
                # Git cache temizle
                self.log_message("üóëÔ∏è Git cache temizleniyor...")
                subprocess.run("git gc", shell=True, capture_output=True, text=True, timeout=30)
                
                # Git ignore g√ºncelle
                gitignore_path = os.path.join(self.current_directory, ".gitignore")
                if not os.path.exists(gitignore_path):
                    self.log_message("üìù .gitignore olu≈üturuluyor...")
                    with open(gitignore_path, "w", encoding="utf-8") as f:
                        f.write("# GitAuto tarafƒ±ndan olu≈üturuldu\n")
                        f.write("# Dependencies\n")
                        f.write("node_modules/\n")
                        f.write("npm-debug.log*\n")
                        f.write("yarn-debug.log*\n")
                        f.write("yarn-error.log*\n")
                        f.write("package-lock.json\n")
                        f.write("yarn.lock\n")
                        f.write("\n# Build outputs\n")
                        f.write("build/\n")
                        f.write("dist/\n")
                        f.write("out/\n")
                        f.write("target/\n")
                        f.write("*.exe\n")
                        f.write("*.msi\n")
                        f.write("*.dmg\n")
                        f.write("*.app\n")
                        f.write("\n# Large files\n")
                        f.write("*.zip\n")
                        f.write("*.tar.gz\n")
                        f.write("*.rar\n")
                        f.write("*.7z\n")
                        f.write("*.iso\n")
                        f.write("*.dmg\n")
                        f.write("*.pkg\n")
                        f.write("\n# Python\n")
                        f.write("__pycache__/\n")
                        f.write("*.pyc\n")
                        f.write("*.pyo\n")
                        f.write("*.pyd\n")
                        f.write("*.so\n")
                        f.write("\n# IDE\n")
                        f.write(".vscode/\n")
                        f.write(".idea/\n")
                        f.write("*.swp\n")
                        f.write("*.swo\n")
                        f.write("\n# Logs\n")
                        f.write("*.log\n")
                        f.write("logs/\n")
                        f.write("*.pid\n")
                        f.write("*.seed\n")
                        f.write("\n# OS\n")
                        f.write(".DS_Store\n")
                        f.write("Thumbs.db\n")
                        f.write("desktop.ini\n")
                        f.write("\n# Cache\n")
                        f.write(".cache/\n")
                        f.write("*.cache\n")
                        f.write("tmp/\n")
                        f.write("temp/\n")
                
                # B√ºy√ºk dosyalarƒ± tespit et ve filtrele
                self.log_message("üîç B√ºy√ºk dosyalar tespit ediliyor...")
                self.detect_and_filter_large_files()
                
                # Gereksiz dosyalarƒ± kaldƒ±r
                self.log_message("üìÅ Gereksiz dosyalar kaldƒ±rƒ±lƒ±yor...")
                
                # √ñnce b√ºy√ºk dosyalarƒ± Git cache'inden kaldƒ±r
                self.log_message("üóëÔ∏è B√ºy√ºk dosyalar Git cache'inden kaldƒ±rƒ±lƒ±yor...")
                self.remove_large_files_from_git()
                
                # T√ºm dosyalarƒ± cache'den kaldƒ±r
                subprocess.run("git rm -r --cached .", shell=True, capture_output=True, text=True, timeout=30)
                
                # .gitignore'ƒ± g√ºncelle ve tekrar ekle
                subprocess.run("git add .gitignore", shell=True, capture_output=True, text=True, timeout=10)
                
                # Temizlenmi≈ü dosyalarƒ± ekle
                subprocess.run("git add .", shell=True, capture_output=True, text=True, timeout=60)
                
                # Commit (konfig√ºrasyon kontrol√º ile)
                self.log_message("üíæ Temizlik commit'i yapƒ±lƒ±yor...")
                
                # Git konfig√ºrasyonunu kontrol et
                user_result = subprocess.run("git config user.name", shell=True, capture_output=True, text=True, timeout=5)
                if user_result.returncode != 0 or not user_result.stdout.strip():
                    subprocess.run('git config user.name "GitAuto"', shell=True, capture_output=True, text=True, timeout=5)
                
                email_result = subprocess.run("git config user.email", shell=True, capture_output=True, text=True, timeout=5)
                if email_result.returncode != 0 or not email_result.stdout.strip():
                    subprocess.run('git config user.email "gitauto@users.noreply.github.com"', shell=True, capture_output=True, text=True, timeout=5)
                
                commit_result = subprocess.run('git commit -m "Repository temizlendi - GitAuto"', 
                             shell=True, capture_output=True, text=True, timeout=30)
                
                if commit_result.returncode != 0:
                    self.log_message("‚ö†Ô∏è Commit hatasƒ±, alternatif y√∂ntem deneniyor...")
                    subprocess.run('git commit -m "Repository temizlendi - GitAuto" --allow-empty', 
                                 shell=True, capture_output=True, text=True, timeout=30)
                
                os.chdir(original_dir)
                
                self.log_message("‚úÖ Repository ba≈üarƒ±yla temizlendi!")
                messagebox.showinfo("Ba≈üarƒ±lƒ±! üéâ", "Repository temizlendi!\n\nArtƒ±k daha hƒ±zlƒ± √ßalƒ±≈üacak.")
                
        except Exception as e:
            self.log_message(f"‚ùå Repository temizleme hatasƒ±: {e}")
            messagebox.showerror("Hata", f"Repository temizleme hatasƒ±:\n{e}")

    def detect_and_filter_large_files(self):
        """B√ºy√ºk dosyalarƒ± tespit et ve .gitignore'a ekle"""
        try:
            self.log_message("üîç B√ºy√ºk dosyalar taranƒ±yor...")
            gitignore_path = os.path.join(self.current_directory, ".gitignore")
            
            # .gitignore yoksa olu≈ütur
            if not os.path.exists(gitignore_path):
                with open(gitignore_path, "w", encoding="utf-8") as f:
                    f.write("# GitAuto tarafƒ±ndan olu≈üturuldu\n")
            
            # √ñnce node_modules klas√∂r√ºn√º tamamen yoksay
            node_modules_path = os.path.join(self.current_directory, "node_modules")
            if os.path.exists(node_modules_path):
                self.log_message("üö´ node_modules klas√∂r√º tespit edildi - tamamen yoksayƒ±lƒ±yor")
                
                # .gitignore'a node_modules ekle
                with open(gitignore_path, "a", encoding="utf-8") as f:
                    f.write("\n# Node.js dependencies - COMPLETELY IGNORED\n")
                    f.write("node_modules/\n")
                    f.write("node_modules/**\n")
                    f.write("**/node_modules/\n")
                    f.write("**/node_modules/**\n")
                
                # Git cache'den de kaldƒ±r
                try:
                    subprocess.run("git rm -r --cached node_modules", shell=True, 
                                 capture_output=True, text=True, cwd=self.current_directory, timeout=30)
                    self.log_message("‚úÖ node_modules Git cache'den kaldƒ±rƒ±ldƒ±")
                except:
                    pass
            
            large_file_threshold = 50 * 1024 * 1024  # 50MB
            large_files = []
            
            # Proje klas√∂r√ºndeki t√ºm dosyalarƒ± tara
            for root, dirs, files in os.walk(self.current_directory):
                # .git ve node_modules klas√∂rlerini atla
                if '.git' in dirs:
                    dirs.remove('.git')
                if 'node_modules' in dirs:
                    dirs.remove('node_modules')
                
                for file in files:
                    file_path = os.path.join(root, file)
                    try:
                        file_size = os.path.getsize(file_path)
                        if file_size > large_file_threshold:
                            # Dosya yolƒ±nƒ± proje klas√∂r√ºne g√∂re relatif yap
                            rel_path = os.path.relpath(file_path, self.current_directory)
                            large_files.append((rel_path, file_size))
                    except (OSError, PermissionError):
                        continue
            
            if large_files:
                self.log_message(f"üö® {len(large_files)} b√ºy√ºk dosya tespit edildi:")
                for file_path, file_size in sorted(large_files, key=lambda x: x[1], reverse=True):
                    size_mb = file_size / (1024 * 1024)
                    self.log_message(f"  üìÅ {file_path} ({size_mb:.1f} MB)")
                
                # .gitignore dosyasƒ±nƒ± g√ºncelle
                if os.path.exists(gitignore_path):
                    with open(gitignore_path, "a", encoding="utf-8") as f:
                        f.write("\n# Large files detected by GitAuto\n")
                        for file_path, _ in large_files:
                            # Dosya yolƒ±nƒ± .gitignore formatƒ±na √ßevir
                            if os.path.sep == '\\':  # Windows
                                file_path = file_path.replace('\\', '/')
                            f.write(f"{file_path}\n")
                    
                    self.log_message("‚úÖ .gitignore dosyasƒ± b√ºy√ºk dosyalarla g√ºncellendi")
                else:
                    self.log_message("‚ö†Ô∏è .gitignore dosyasƒ± bulunamadƒ±, b√ºy√ºk dosyalar eklenebilir")
            else:
                self.log_message("‚úÖ B√ºy√ºk dosya tespit edilmedi")
                
        except Exception as e:
            self.log_message(f"‚ö†Ô∏è B√ºy√ºk dosya tespiti sƒ±rasƒ±nda hata: {e}")

    def remove_large_files_from_git(self):
        """Git cache'inden b√ºy√ºk dosyalarƒ± kaldƒ±r"""
        try:
            # Git cache'deki b√ºy√ºk dosyalarƒ± bul
            self.log_message("üîç Git cache'deki b√ºy√ºk dosyalar aranƒ±yor...")
            
            # Git ls-files ile cache'deki dosyalarƒ± listele
            result = subprocess.run("git ls-files", shell=True, capture_output=True, 
                                  text=True, cwd=self.current_directory, timeout=30)
            
            if result.returncode != 0:
                self.log_message("‚ö†Ô∏è Git cache listesi alƒ±namadƒ±")
                return
            
            large_files_in_git = []
            large_file_threshold = 50 * 1024 * 1024  # 50MB
            
            for line in result.stdout.strip().split('\n'):
                if not line.strip():
                    continue
                
                file_path = os.path.join(self.current_directory, line)
                if os.path.exists(file_path):
                    try:
                        file_size = os.path.getsize(file_path)
                        if file_size > large_file_threshold:
                            large_files_in_git.append((line, file_size))
                    except (OSError, PermissionError):
                        continue
            
            if large_files_in_git:
                self.log_message(f"üö® Git cache'de {len(large_files_in_git)} b√ºy√ºk dosya bulundu:")
                
                for file_path, file_size in sorted(large_files_in_git, key=lambda x: x[1], reverse=True):
                    size_mb = file_size / (1024 * 1024)
                    self.log_message(f"  üìÅ {file_path} ({size_mb:.1f} MB)")
                    
                    # B√ºy√ºk dosyayƒ± Git cache'inden kaldƒ±r
                    try:
                        subprocess.run(f'git rm --cached "{file_path}"', shell=True, 
                                     capture_output=True, text=True, cwd=self.current_directory, timeout=10)
                        self.log_message(f"  ‚úÖ {file_path} Git cache'den kaldƒ±rƒ±ldƒ±")
                    except Exception as e:
                        self.log_message(f"  ‚ùå {file_path} kaldƒ±rƒ±lamadƒ±: {e}")
                
                # .gitignore'a ekle
                gitignore_path = os.path.join(self.current_directory, ".gitignore")
                if os.path.exists(gitignore_path):
                    with open(gitignore_path, "a", encoding="utf-8") as f:
                        f.write("\n# Large files removed from Git cache\n")
                        for file_path, _ in large_files_in_git:
                            # Dosya yolƒ±nƒ± .gitignore formatƒ±na √ßevir
                            if os.path.sep == '\\':  # Windows
                                file_path = file_path.replace('\\', '/')
                            f.write(f"{file_path}\n")
                    
                    self.log_message("‚úÖ .gitignore dosyasƒ± g√ºncellendi")
                
                # √ñzel olarak node_modules klas√∂r√ºn√º kaldƒ±r
                if any('node_modules' in file_path for file_path, _ in large_files_in_git):
                    self.log_message("üö´ node_modules klas√∂r√º Git cache'den kaldƒ±rƒ±lƒ±yor...")
                    try:
                        # √ñnce t√ºm node_modules dosyalarƒ±nƒ± tek tek kaldƒ±r
                        subprocess.run("git rm -r --cached node_modules", shell=True, 
                                     capture_output=True, text=True, cwd=self.current_directory, timeout=30)
                        
                        # Git history'den de temizle (daha agresif)
                        subprocess.run("git filter-branch --force --index-filter 'git rm -r --cached --ignore-unmatch node_modules' --prune-empty --tag-name-filter cat -- --all", 
                                     shell=True, capture_output=True, text=True, cwd=self.current_directory, timeout=60)
                        
                        # Git garbage collection yap
                        subprocess.run("git gc --prune=now", shell=True, 
                                     capture_output=True, text=True, cwd=self.current_directory, timeout=30)
                        
                        self.log_message("‚úÖ node_modules klas√∂r√º Git history'den tamamen temizlendi")
                    except Exception as e:
                        self.log_message(f"‚ö†Ô∏è node_modules temizlenemedi: {e}")
                        
                        # Alternatif y√∂ntem: Force clean
                        self.log_message("üîÑ Alternatif temizlik y√∂ntemi deneniyor...")
                        try:
                            subprocess.run("git clean -fdx", shell=True, 
                                         capture_output=True, text=True, cwd=self.current_directory, timeout=30)
                            subprocess.run("git reset --hard HEAD", shell=True, 
                                         capture_output=True, text=True, cwd=self.current_directory, timeout=30)
                            self.log_message("‚úÖ Alternatif temizlik tamamlandƒ±")
                        except Exception as e2:
                            self.log_message(f"‚ùå Alternatif temizlik de ba≈üarƒ±sƒ±z: {e2}")
                            
                            # Son √ßare: Repository'yi tamamen yeniden ba≈ülat
                            self.log_message("üö® Son √ßare: Repository tamamen yeniden ba≈ülatƒ±lƒ±yor...")
                            try:
                                # .git klas√∂r√ºn√º yedekle
                                git_backup = os.path.join(self.current_directory, ".git_backup")
                                if os.path.exists(os.path.join(self.current_directory, ".git")):
                                    import shutil
                                    shutil.move(os.path.join(self.current_directory, ".git"), git_backup)
                                    self.log_message("‚úÖ .git klas√∂r√º yedeklendi")
                                
                                # Yeni repository ba≈ülat
                                subprocess.run("git init", shell=True, 
                                             capture_output=True, text=True, cwd=self.current_directory, timeout=10)
                                
                                # .gitignore'ƒ± g√ºncelle
                                self.update_gitignore_for_large_files()
                                
                                self.log_message("‚úÖ Repository yeniden ba≈ülatƒ±ldƒ±")
                                self.log_message("üí° Artƒ±k b√ºy√ºk dosyalar olmadan commit yapabilirsiniz")
                                
                            except Exception as e3:
                                self.log_message(f"‚ùå Repository yeniden ba≈ülatƒ±lamadƒ±: {e3}")
                                # Yedekten geri y√ºkle
                                if os.path.exists(git_backup):
                                    import shutil
                                    shutil.move(git_backup, os.path.join(self.current_directory, ".git"))
                                    self.log_message("‚úÖ .git klas√∂r√º yedekten geri y√ºklendi")
            else:
                self.log_message("‚úÖ Git cache'de b√ºy√ºk dosya bulunamadƒ±")
                
        except Exception as e:
            self.log_message(f"‚ö†Ô∏è Git cache temizliƒüi sƒ±rasƒ±nda hata: {e}")

    def update_gitignore_for_large_files(self):
        """B√ºy√ºk dosyalar i√ßin kapsamlƒ± .gitignore olu≈ütur"""
        try:
            gitignore_path = os.path.join(self.current_directory, ".gitignore")
            
            # Kapsamlƒ± .gitignore i√ßeriƒüi
            gitignore_content = """# GitAuto tarafƒ±ndan olu≈üturuldu - B√ºy√ºk dosyalar i√ßin optimize edildi

# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
package-lock.json
yarn.lock
pnpm-lock.yaml

# Build outputs
build/
dist/
out/
target/
*.exe
*.msi
*.dmg
*.app
*.deb
*.rpm
*.pkg

# Large files
*.zip
*.tar.gz
*.rar
*.7z
*.iso
*.dmg
*.pkg
*.bin
*.dat
*.db
*.sqlite
*.sqlite3

# Python
__pycache__/
*.pyc
*.pyo
*.pyd
*.so
*.egg
*.egg-info/
*.whl

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# Logs
*.log
logs/
*.pid
*.seed
*.out

# OS
.DS_Store
Thumbs.db
desktop.ini
*.tmp
*.temp

# Cache
.cache/
*.cache
tmp/
temp/
.tmp/

# Electron specific
node_modules/electron/
node_modules/electron-builder/
node_modules/electron-packager/

# Large media files
*.mp4
*.avi
*.mov
*.wmv
*.flv
*.mkv
*.webm
*.mp3
*.wav
*.flac
*.aac
*.ogg

# Archives
*.zip
*.tar
*.gz
*.bz2
*.xz
*.rar
*.7z
*.lzma
*.lz4

# Database files
*.db
*.sqlite
*.sqlite3
*.mdb
*.accdb

# Virtual environments
venv/
env/
.venv/
.env/
ENV/

# Backup files
*.bak
*.backup
*.old
*.orig
*.save
"""
            
            with open(gitignore_path, "w", encoding="utf-8") as f:
                f.write(gitignore_content)
            
            self.log_message("‚úÖ Kapsamlƒ± .gitignore dosyasƒ± olu≈üturuldu")
            
        except Exception as e:
            self.log_message(f"‚ö†Ô∏è .gitignore olu≈üturulurken hata: {e}")

    def create_new_branch(self):
        """Yeni branch olu≈ütur"""
        branch_name = self.new_branch_var.get().strip()
        if not branch_name:
            messagebox.showerror("Hata", "Branch adƒ± bo≈ü olamaz!")
            return
        
        # Ge√ßersiz karakterleri kontrol et
        invalid_chars = [' ', '/', '\\', ':', '*', '?', '"', '<', '>', '|']
        if any(char in branch_name for char in invalid_chars):
            messagebox.showerror("Hata", f"Branch adƒ±nda ge√ßersiz karakterler var!\nGe√ßersiz karakterler: {' '.join(invalid_chars)}")
            return
        
        def create_branch():
            try:
                self.log_message(f"üå± Yeni branch olu≈üturuluyor: {branch_name}")
                
                if not os.path.exists(os.path.join(self.current_directory, ".git")):
                    self.log_message("‚ùå Git repository hen√ºz ba≈ülatƒ±lmamƒ±≈ü!")
                    self.root.after(0, lambda: messagebox.showerror("Hata", "Git repository hen√ºz ba≈ülatƒ±lmamƒ±≈ü!\n√ñnce 'Repository Baƒüla' butonunu kullanƒ±n."))
                    return
                
                result = subprocess.run(f"git checkout -b {branch_name}", shell=True, 
                                     capture_output=True, text=True, cwd=self.current_directory, timeout=15)
                
                if result.returncode == 0:
                    self.log_message(f"‚úÖ Branch '{branch_name}' ba≈üarƒ±yla olu≈üturuldu!")
                    
                    # Yeni branch'i hedef branch listesine ekle
                    current_values = list(self.branch_combo['values'])
                    if branch_name not in current_values:
                        current_values.append(branch_name)
                        current_values.sort()
                        self.branch_combo['values'] = current_values
                    
                    # Yeni branch'i otomatik se√ß
                    self.selected_branch.set(branch_name)
                    self.log_message(f"üéØ Hedef branch otomatik '{branch_name}' olarak se√ßildi")
                    
                    self.new_branch_var.set("")
                    
                    # Ba≈üarƒ± mesajƒ±
                    self.root.after(0, lambda: messagebox.showinfo(
                        "Ba≈üarƒ±lƒ±! üéâ",
                        f"üå± Branch '{branch_name}' ba≈üarƒ±yla olu≈üturuldu!\n\n"
                        f"‚úÖ Otomatik olarak hedef branch se√ßildi\n"
                        f"üöÄ Artƒ±k yayƒ±nlama yapabilirsiniz"
                    ))
                    
                else:
                    error_msg = result.stderr or "Bilinmeyen hata"
                    if "already exists" in error_msg:
                        self.log_message(f"‚ö†Ô∏è Branch '{branch_name}' zaten mevcut!")
                        self.selected_branch.set(branch_name)
                        self.log_message(f"üéØ Mevcut branch '{branch_name}' hedef olarak se√ßildi")
                    else:
                        self.log_message(f"‚ùå Branch olu≈üturma hatasƒ±: {error_msg}")
                        self.root.after(0, lambda: messagebox.showerror("Hata", f"Branch olu≈üturma hatasƒ±:\n{error_msg}"))
                        
            except Exception as e:
                error_msg = str(e)  # Hata mesajƒ±nƒ± string olarak sakla
                self.log_message(f"‚ùå Branch olu≈üturma hatasƒ±: {error_msg}")
                self.root.after(0, lambda: messagebox.showerror("Hata", f"Branch olu≈üturma hatasƒ±:\n{error_msg}"))
        
        # Thread'de √ßalƒ±≈ütƒ±r
        threading.Thread(target=create_branch, daemon=True).start()

    def list_branches(self):
        """Mevcut branch'leri listele"""
        def list_branches_thread():
            try:
                self.log_message("üìã Mevcut branch'ler listeleniyor...")
                
                if not self.git_repo_exists:
                    self.log_message("‚ÑπÔ∏è  Git repository hen√ºz ba≈ülatƒ±lmamƒ±≈ü")
                    return
                
                result = subprocess.run("git branch", shell=True, capture_output=True, 
                                     text=True, cwd=self.current_directory)
                
                if result.returncode == 0 and result.stdout:
                    self.log_message("üåø Mevcut Branch'ler:")
                    self.log_message("-" * 30)
                    branches = result.stdout.strip().split('\n')
                    for branch in branches:
                        if branch.strip():
                            if branch.startswith('*'):
                                self.log_message(f"  üåü {branch.strip()} (aktif)")
                            else:
                                self.log_message(f"     {branch.strip()}")
                else:
                    self.log_message("‚ÑπÔ∏è  Hen√ºz branch bulunamadƒ±")
                    
            except Exception as e:
                self.log_message(f"‚ùå Branch listeleme hatasƒ±: {e}")
        
        threading.Thread(target=list_branches_thread, daemon=True).start()

    def start_publication(self):
        """Repository yayƒ±nlama i≈ülemini ba≈ülat - Sadece bo≈ü commit"""
        # Giri≈ü kontrol√º
        if not self.project_name.get().strip():
            messagebox.showerror("Hata", "Proje adƒ± bo≈ü olamaz!")
            return
        
        if not self.github_username.get().strip():
            messagebox.showerror("Hata", "GitHub kullanƒ±cƒ± adƒ± bo≈ü olamaz!")
            return
        
        if not self.git_installed:
            messagebox.showerror("Hata", "Git kurulu deƒüil!\nL√ºtfen √∂nce Git'i y√ºkleyin: https://git-scm.com/downloads")
            return
        
        # Repository varlƒ±ƒüƒ±nƒ± kontrol et
        if not os.path.exists(os.path.join(self.current_directory, ".git")):
            messagebox.showerror("Hata", "Git repository bulunamadƒ±!\n√ñnce README adƒ±mƒ±nda 'Repository Baƒüla' butonunu kullanƒ±n.")
            return
        
        # Onay al - Bo≈ü commit i√ßin
        project_name = self.project_name.get().strip()
        github_username = self.github_username.get().strip()
        commit_message = self.commit_message.get().strip() or "Empty commit for repository setup"
        target_branch = self.selected_branch.get()
        
        confirm_text = f"""üìã Bo≈ü Commit Yayƒ±nlama:

üìÅ Proje: {project_name}
üë§ GitHub: {github_username}
üí¨ Commit: {commit_message}
üåø Branch: {target_branch}

‚ö†Ô∏è Bu i≈ülem sadece bo≈ü commit atacak.
üöÄ Dosya yayƒ±nlama son adƒ±mda yapƒ±lacak.

‚úÖ Devam edilsin mi?"""
        
        if not messagebox.askyesno("Onay", confirm_text):
            return
        
        # ƒ∞≈ülemi ba≈ülat
        self.main_button.config(state="disabled")
        self.progress.start()
        
        # Thread'de √ßalƒ±≈ütƒ±r
        threading.Thread(target=self.publish_repository, daemon=True).start()

    def publish_repository(self):
        """Sadece bo≈ü commit at - Dosya yayƒ±nlama son adƒ±mda"""
        try:
            project_name = self.project_name.get().strip()
            github_username = self.github_username.get().strip()
            commit_message = self.commit_message.get().strip() or "Empty commit for repository setup"
            target_branch = self.selected_branch.get() or "main"
            
            repo_url = f"https://github.com/{github_username}/{project_name}.git"
            
            self.log_message("üöÄ Bo≈ü commit yayƒ±nlama ba≈ülatƒ±lƒ±yor...")
            
            # Git repository kontrol√º
            git_dir = os.path.join(self.current_directory, ".git")
            if not os.path.exists(git_dir):
                self.log_message("‚ùå Git repository bulunamadƒ±! √ñnce 'Repository Baƒüla' kullanƒ±n.")
                raise Exception("Git repository bulunamadƒ±! √ñnce 'Repository Baƒüla' kullanƒ±n.")
            
            # Git konfig√ºrasyonunu kontrol et
            self.log_message("‚öôÔ∏è Git konfig√ºrasyonu kontrol ediliyor...")
            
            user_result = subprocess.run("git config user.name", shell=True, capture_output=True, 
                                       text=True, cwd=self.current_directory, timeout=5)
            if user_result.returncode != 0 or not user_result.stdout.strip():
                subprocess.run(f'git config user.name "{github_username}"', shell=True, 
                             capture_output=True, text=True, cwd=self.current_directory, timeout=5)
                self.log_message("üë§ Git user.name ayarlandƒ±")
            
            email_result = subprocess.run("git config user.email", shell=True, capture_output=True, 
                                        text=True, cwd=self.current_directory, timeout=5)
            if email_result.returncode != 0 or not email_result.stdout.strip():
                subprocess.run(f'git config user.email "{github_username}@users.noreply.github.com"', 
                             shell=True, capture_output=True, text=True, cwd=self.current_directory, timeout=5)
                self.log_message("üìß Git user.email ayarlandƒ±")
            
            # Bo≈ü commit at
            self.log_message(f"üíæ Bo≈ü commit atƒ±lƒ±yor: {commit_message}")
            result = subprocess.run(f'git commit --allow-empty -m "{commit_message}"', shell=True, 
                                 capture_output=True, text=True, cwd=self.current_directory, timeout=10)
            
            if result.returncode != 0:
                error_msg = result.stderr.strip() if result.stderr else "Bilinmeyen commit hatasƒ±"
                self.log_message(f"‚ö†Ô∏è Bo≈ü commit hatasƒ±: {error_msg}")
                raise Exception(f"Bo≈ü commit hatasƒ±: {error_msg}")
            
            self.log_message("‚úÖ Bo≈ü commit ba≈üarƒ±yla atƒ±ldƒ±")
            
            # Push i≈ülemi
            self.log_message(f"üöÄ '{target_branch}' branch'i GitHub'a push ediliyor...")
            result = subprocess.run(f"git push origin {target_branch}", shell=True, capture_output=True, 
                                 text=True, cwd=self.current_directory, timeout=60)
            
            if result.returncode != 0:
                error_msg = result.stderr.strip() if result.stderr else "Bilinmeyen push hatasƒ±"
                self.log_message(f"‚ö†Ô∏è Push hatasƒ±: {error_msg}")
                raise Exception(f"Push hatasƒ±: {error_msg}")
            
            self.log_message("‚úÖ Bo≈ü commit GitHub'a ba≈üarƒ±yla push edildi!")
            self.log_message("üéâ Repository hazƒ±rlandƒ± - Son adƒ±mda dosyalar yayƒ±nlanacak")
            
            # Ba≈üarƒ± mesajƒ± g√∂ster
            self.root.after(0, lambda: messagebox.showinfo(
                "Ba≈üarƒ±lƒ±! üéâ",
                f"‚úÖ Bo≈ü commit ba≈üarƒ±yla yayƒ±nlandƒ±!\n\n"
                f"üìç Repository: {repo_url}\n"
                f"üåø Branch: {target_branch}\n"
                f"üí¨ Commit: {commit_message}\n\n"
                "üöÄ Son adƒ±mda t√ºm dosyalar yayƒ±nlanacak!"
            ))
            
        except Exception as e:
            self.log_message(f"‚ùå Bo≈ü commit yayƒ±nlama hatasƒ±: {e}")
            self.root.after(0, lambda: messagebox.showerror("Hata", f"Bo≈ü commit yayƒ±nlama hatasƒ±:\n{e}"))
        
        finally:
            # UI'ƒ± g√ºncelle
            self.root.after(0, self.publication_finished)

    def publication_finished(self):
        """Yayƒ±nlama i≈ülemi tamamlandƒ±"""
        # Yayƒ±nlama tamamlandƒ±ktan sonra butonlarƒ± g√ºncelle
        if hasattr(self, 'main_button'):
            try:
                if self.main_button.winfo_exists():
                    self.main_button.config(state="normal")
            except tk.TclError:
                pass  # Widget referans hatasƒ± durumunda sessizce devam et
        
        # README adƒ±mƒ±ndaki butonu da g√ºncelle (eƒüer varsa)
        if hasattr(self, 'connect_button_readme'):
            try:
                if self.connect_button_readme.winfo_exists():
                    self.connect_button_readme.config(state="normal")
            except tk.TclError:
                pass  # Widget referans hatasƒ± durumunda sessizce devam et
        
        self.progress.stop()
        self.check_git_status()

    def list_folder_contents(self):
        """Se√ßilen klas√∂rdeki dosyalarƒ± listele"""
        try:
            if not os.path.exists(self.current_directory):
                return
            
            self.log_message(f"üìã Klas√∂r i√ßeriƒüi ({self.current_directory}):")
            self.log_message("-" * 50)
            
            # Dosya ve klas√∂rleri listele
            items = os.listdir(self.current_directory)
            files = []
            folders = []
            
            for item in items:
                item_path = os.path.join(self.current_directory, item)
                if os.path.isfile(item_path):
                    files.append(item)
                elif os.path.isdir(item_path):
                    folders.append(item)
            
            # Klas√∂rleri g√∂ster
            if folders:
                self.log_message("üìÅ Klas√∂rler:")
                for folder in sorted(folders):
                    self.log_message(f"  üìÅ {folder}")
            
            # Dosyalarƒ± g√∂ster
            if files:
                self.log_message("üìÑ Dosyalar:")
                for file in sorted(files):
                    # Git, sistem ve gereksiz dosyalarƒ± gizle
                    if not file.startswith('.') and file not in ['__pycache__', 'node_modules', 'build', 'dist', 'out', 'target']:
                        self.log_message(f"  üìÑ {file}")
            
            # README.md kontrol√º
            readme_path = os.path.join(self.current_directory, "README.md")
            if os.path.exists(readme_path):
                self.log_message("‚úÖ README.md dosyasƒ± bulundu")
                self.readme_var.set("keep")  # Otomatik olarak koru se√ßeneƒüini se√ß
            else:
                self.log_message("‚ÑπÔ∏è  README.md dosyasƒ± bulunamadƒ±")
                self.readme_var.set("create")  # Otomatik olarak olu≈ütur se√ßeneƒüini se√ß
            
            self.log_message("-" * 50)
            
        except Exception as e:
            self.log_message(f"‚ùå Klas√∂r i√ßeriƒüi listelenirken hata: {e}")

def main():
    """Ana uygulama - modern tasarƒ±m"""
    root = tk.Tk()
    
    # Modern tema ve stil ayarlarƒ±
    style = ttk.Style()
    style.theme_use('clam')
    
    # Pencere ikonu ve ba≈ülƒ±k
    try:
        root.iconbitmap("icon.ico")  # Eƒüer icon dosyasƒ± varsa
    except:
        pass  # Icon yoksa devam et
    
    # Modern pencere ayarlarƒ±
    root.configure(bg="#ffffff")
    root.option_add('*TFrame*background', '#ffffff')
    root.option_add('*TLabel*background', '#ffffff')
    
    app = GitAutoGUI(root)
    
    # Pencere kapatma olayƒ± - modern dialog
    def on_closing():
        if messagebox.askokcancel("üö™ √áƒ±kƒ±≈ü", 
                                 "GitAuto'dan √ßƒ±kmak istediƒüinizden emin misiniz?\n\n"
                                 "Kaydedilmemi≈ü deƒüi≈üiklikler kaybolabilir."):
            root.destroy()
    
    root.protocol("WM_DELETE_WINDOW", on_closing)
    
    # Pencereyi ekranƒ±n ortasƒ±na yerle≈ütir
    root.update_idletasks()
    x = (root.winfo_screenwidth() // 2) - (root.winfo_width() // 2)
    y = (root.winfo_screenheight() // 2) - (root.winfo_height() // 2)
    root.geometry(f"+{x}+{y}")
    
    # Pencereyi √∂ne getir
    root.lift()
    root.attributes('-topmost', True)
    root.after_idle(root.attributes, '-topmost', False)
    
    root.mainloop()

if __name__ == "__main__":
    main()

    def publication_finished(self):
        """Yayƒ±nlama i≈ülemi tamamlandƒ±"""
        # Yayƒ±nlama tamamlandƒ±ktan sonra butonlarƒ± g√ºncelle
        if hasattr(self, 'main_button'):
            try:
                if self.main_button.winfo_exists():
                    self.main_button.config(state="normal")
            except tk.TclError:
                pass  # Widget referans hatasƒ± durumunda sessizce devam et
        
        # README adƒ±mƒ±ndaki butonu da g√ºncelle (eƒüer varsa)
        if hasattr(self, 'connect_button_readme'):
            try:
                if self.connect_button_readme.winfo_exists():
                    self.connect_button_readme.config(state="normal")
            except tk.TclError:
                pass  # Widget referans hatasƒ± durumunda sessizce devam et
        
        self.progress.stop()
        self.check_git_status()

    def list_folder_contents(self):
        """Se√ßilen klas√∂rdeki dosyalarƒ± listele"""
        try:
            if not os.path.exists(self.current_directory):
                return
            
            self.log_message(f"üìã Klas√∂r i√ßeriƒüi ({self.current_directory}):")
            self.log_message("-" * 50)
            
            # Dosya ve klas√∂rleri listele
            items = os.listdir(self.current_directory)
            files = []
            folders = []
            
            for item in items:
                item_path = os.path.join(self.current_directory, item)
                if os.path.isfile(item_path):
                    files.append(item)
                elif os.path.isdir(item_path):
                    folders.append(item)
            
            # Klas√∂rleri g√∂ster
            if folders:
                self.log_message("üìÅ Klas√∂rler:")
                for folder in sorted(folders):
                    self.log_message(f"  üìÅ {folder}")
            
            # Dosyalarƒ± g√∂ster
            if files:
                self.log_message("üìÑ Dosyalar:")
                for file in sorted(files):
                    # Git, sistem ve gereksiz dosyalarƒ± gizle
                    if not file.startswith('.') and file not in ['__pycache__', 'node_modules', 'build', 'dist', 'out', 'target']:
                        self.log_message(f"  üìÑ {file}")
            
            # README.md kontrol√º
            readme_path = os.path.join(self.current_directory, "README.md")
            if os.path.exists(readme_path):
                self.log_message("‚úÖ README.md dosyasƒ± bulundu")
                self.readme_var.set("keep")  # Otomatik olarak koru se√ßeneƒüini se√ß
            else:
                self.log_message("‚ÑπÔ∏è  README.md dosyasƒ± bulunamadƒ±")
                self.readme_var.set("create")  # Otomatik olarak olu≈ütur se√ßeneƒüini se√ß
            
            self.log_message("-" * 50)
            
        except Exception as e:
            self.log_message(f"‚ùå Klas√∂r i√ßeriƒüi listelenirken hata: {e}")

def main():
    """Ana uygulama - modern tasarƒ±m"""
    root = tk.Tk()
    
    # Modern tema ve stil ayarlarƒ±
    style = ttk.Style()
    style.theme_use('clam')
    
    # Pencere ikonu ve ba≈ülƒ±k
    try:
        root.iconbitmap("icon.ico")  # Eƒüer icon dosyasƒ± varsa
    except:
        pass  # Icon yoksa devam et
    
    # Modern pencere ayarlarƒ±
    root.configure(bg="#ffffff")
    root.option_add('*TFrame*background', '#ffffff')
    root.option_add('*TLabel*background', '#ffffff')
    
    app = GitAutoGUI(root)
    
    # Pencere kapatma olayƒ± - modern dialog
    def on_closing():
        if messagebox.askokcancel("üö™ √áƒ±kƒ±≈ü", 
                                 "GitAuto'dan √ßƒ±kmak istediƒüinizden emin misiniz?\n\n"
                                 "Kaydedilmemi≈ü deƒüi≈üiklikler kaybolabilir."):
            root.destroy()
    
    root.protocol("WM_DELETE_WINDOW", on_closing)
    
    # Pencereyi ekranƒ±n ortasƒ±na yerle≈ütir
    root.update_idletasks()
    x = (root.winfo_screenwidth() // 2) - (root.winfo_width() // 2)
    y = (root.winfo_screenheight() // 2) - (root.winfo_height() // 2)
    root.geometry(f"+{x}+{y}")
    
    # Pencereyi √∂ne getir
    root.lift()
    root.attributes('-topmost', True)
    root.after_idle(root.attributes, '-topmost', False)
    
    root.mainloop()

if __name__ == "__main__":
    main()

