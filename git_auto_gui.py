#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GitAuto GUI - Windows Uygulamasƒ±
Adƒ±m adƒ±m ilerleyen modern aray√ºz ile Git repository y√∂netimi
"""

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext, filedialog
import os
import subprocess
import sys
from pathlib import Path
import threading
import queue

class GitAutoGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("üöÄ GitAuto - Adƒ±m Adƒ±m Git Repository Y√∂netimi")
        self.root.geometry("900x900")
        self.root.resizable(True, True)
        
        # Modern stil tanƒ±mlamalarƒ±
        self.setup_styles()
        
        # Ana deƒüi≈ükenler
        self.project_name = tk.StringVar()
        self.github_username = tk.StringVar()
        self.commit_message = tk.StringVar(value="first commit")
        self.selected_branch = tk.StringVar(value="main")
        self.readme_var = tk.StringVar(value="keep")
        self.current_directory = os.getcwd()
        
        # Git durumu
        self.git_installed = False
        self.git_repo_exists = False
        
        # Adƒ±m y√∂netimi
        self.current_step = 0
        self.total_steps = 6
        
        # Log mesajlarƒ± i√ßin queue
        self.log_queue = queue.Queue()
        
        # Aray√ºz olu≈ütur
        self.create_widgets()
        
        # ƒ∞lk adƒ±mƒ± g√∂ster
        self.show_step(0)
        
        # Git durumunu kontrol et
        self.check_git_status()
        
        # Log g√ºncellemelerini ba≈ülat
        self.update_log()

    def setup_styles(self):
        """Modern CSS-style buton ve widget stilleri tanƒ±mla"""
        style = ttk.Style()
        
        # Primary buton stili (mavi)
        style.configure("Primary.TButton",
                       background="#2563eb",
                       foreground="white",
                       borderwidth=0,
                       focuscolor="none",
                       font=("Segoe UI", 10, "bold"))
        
        style.map("Primary.TButton",
                 background=[("active", "#1d4ed8"), ("pressed", "#1e40af")],
                 foreground=[("active", "white"), ("pressed", "white")])
        
        # Accent buton stili (ye≈üil)
        style.configure("Accent.TButton",
                       background="#059669",
                       foreground="white",
                       borderwidth=0,
                       focuscolor="none",
                       font=("Segoe UI", 10, "bold"))
        
        style.map("Accent.TButton",
                 background=[("active", "#047857"), ("pressed", "#065f46")],
                 foreground=[("active", "white"), ("pressed", "white")])
        
        # Secondary buton stili (gri)
        style.configure("Secondary.TButton",
                       background="#64748b",
                       foreground="white",
                       borderwidth=0,
                       focuscolor="none",
                       font=("Segoe UI", 10))
        
        style.map("Secondary.TButton",
                 background=[("active", "#475569"), ("pressed", "#334155")],
                 foreground=[("active", "white"), ("pressed", "white")])
        
        # Progress bar stili
        style.configure("Accent.Horizontal.TProgressbar",
                       background="#2563eb",
                       troughcolor="#e2e8f0",
                       borderwidth=0,
                       lightcolor="#3b82f6",
                       darkcolor="#1d4ed8")
        
        # LabelFrame stili
        style.configure("TLabelframe",
                       background="#ffffff",
                       borderwidth=1,
                       relief="solid")
        
        style.configure("TLabelframe.Label",
                       font=("Segoe UI", 11, "bold"),
                       foreground="#1e293b",
                       background="#ffffff")
        
        # Entry stili
        style.configure("TEntry",
                       fieldbackground="#f8fafc",
                       borderwidth=1,
                       relief="solid",
                       focuscolor="#2563eb")
        
        # Combobox stili
        style.configure("TCombobox",
                       fieldbackground="#f8fafc",
                       borderwidth=1,
                       relief="solid",
                       focuscolor="#2563eb")
        
        # Frame stili
        style.configure("TFrame",
                       background="#ffffff")
        
        # Radiobutton stili
        style.configure("TRadiobutton",
                       background="#ffffff",
                       font=("Segoe UI", 10),
                       foreground="#1e293b")
        
        style.map("TRadiobutton",
                 background=[("active", "#f1f5f9"), ("selected", "#dbeafe")],
                 foreground=[("active", "#1e293b"), ("selected", "#1e40af")])

    def create_widgets(self):
        """Adƒ±m adƒ±m ilerleyen widget'larƒ± olu≈ütur"""
        # Ana frame
        main_frame = ttk.Frame(self.root, padding="20")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Grid aƒüƒ±rlƒ±klarƒ±
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        
        # Ba≈ülƒ±k frame
        title_frame = ttk.Frame(main_frame)
        title_frame.grid(row=0, column=0, pady=(0, 20), sticky=(tk.W, tk.E))
        title_frame.columnconfigure(0, weight=1)
        
        title_label = ttk.Label(title_frame, 
                               text="üöÄ GitAuto", 
                               font=("Segoe UI", 24, "bold"),
                               foreground="#2563eb")
        title_label.grid(row=0, column=0, pady=(0, 5))
        
        subtitle_label = ttk.Label(title_frame, 
                                   text="Adƒ±m Adƒ±m Git Repository Y√∂netimi", 
                                   font=("Segoe UI", 12),
                                   foreground="#64748b")
        subtitle_label.grid(row=1, column=0)
        
        # Adƒ±m g√∂stergesi
        step_frame = ttk.Frame(main_frame)
        step_frame.grid(row=1, column=0, pady=(0, 20), sticky=(tk.W, tk.E))
        step_frame.columnconfigure(0, weight=1)
        
        self.step_label = ttk.Label(step_frame, 
                                   text="Adƒ±m 1/5: Proje Bilgileri", 
                                   font=("Segoe UI", 14, "bold"),
                                   foreground="#1e293b")
        self.step_label.grid(row=0, column=0, pady=(0, 10))
        
        # Adƒ±m progress bar
        self.step_progress = ttk.Progressbar(step_frame, 
                                            mode='determinate', 
                                            style="Accent.Horizontal.TProgressbar",
                                            length=400)
        self.step_progress.grid(row=1, column=0)
        self.step_progress['value'] = 20
        
        # ƒ∞√ßerik frame - her adƒ±mda deƒüi≈üecek
        self.content_frame = ttk.Frame(main_frame)
        self.content_frame.grid(row=2, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 20))
        self.content_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(2, weight=1)
        
        # Navigasyon butonlarƒ±
        nav_frame = ttk.Frame(main_frame)
        nav_frame.grid(row=3, column=0, pady=(20, 0), sticky=(tk.W, tk.E))
        nav_frame.columnconfigure(0, weight=1)
        nav_frame.columnconfigure(1, weight=1)
        
        self.prev_button = ttk.Button(nav_frame, text="‚¨ÖÔ∏è √ñnceki", 
                                     command=self.previous_step, 
                                     style="Secondary.TButton",
                                     state="disabled",
                                     width=15)
        self.prev_button.grid(row=0, column=0, padx=(0, 10))
        
        self.next_button = ttk.Button(nav_frame, text="Sonraki ‚û°Ô∏è", 
                                    command=self.next_step, 
                                    style="Primary.TButton",
                                    width=15)
        self.next_button.grid(row=0, column=1, padx=(10, 0))
        
        # Log frame - her adƒ±mda g√∂r√ºn√ºr
        log_frame = ttk.LabelFrame(main_frame, text="üìã ƒ∞≈ülem Loglarƒ±", padding="20")
        log_frame.grid(row=4, column=0, sticky=(tk.W, tk.E), pady=(20, 0))
        log_frame.columnconfigure(0, weight=1)
        
        self.log_text = scrolledtext.ScrolledText(log_frame, height=8, width=80, 
                                                font=("Consolas", 9), 
                                                bg="#f8fafc", fg="#1e293b",
                                                insertbackground="#2563eb")
        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E))
        
        # Progress bar
        progress_frame = ttk.Frame(main_frame)
        progress_frame.grid(row=5, column=0, sticky=(tk.W, tk.E), pady=(10, 0))
        progress_frame.columnconfigure(0, weight=1)
        
        self.progress = ttk.Progressbar(progress_frame, mode='indeterminate', 
                                       style="Accent.Horizontal.TProgressbar")
        self.progress.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # Status bar
        self.status_bar = ttk.Label(progress_frame, text="Hazƒ±r", 
                                   font=("Segoe UI", 9), foreground="#64748b")
        self.status_bar.grid(row=1, column=0, sticky=tk.W)

    def show_step(self, step_number):
        """Belirtilen adƒ±mƒ± g√∂ster"""
        self.current_step = step_number
        
        # ƒ∞√ßerik frame'i temizle
        for widget in self.content_frame.winfo_children():
            widget.destroy()
        
        # Adƒ±m g√∂stergesini g√ºncelle
        step_names = [
            "Proje Bilgileri",
            "README.md Y√∂netimi", 
            "AI README Olu≈üturucu",
            "Git Durumu",
            "Branch Y√∂netimi",
            "Repository ƒ∞≈ülemleri"
        ]
        
        self.step_label.config(text=f"Adƒ±m {step_number + 1}/6: {step_names[step_number]}")
        self.step_progress['value'] = (step_number + 1) * 16.67
        
        # Navigasyon butonlarƒ±nƒ± g√ºncelle
        if step_number == 0:
            self.prev_button.config(state="disabled")
        else:
            self.prev_button.config(state="normal")
            
        if step_number == self.total_steps - 1:  # Son adƒ±m (Adƒ±m 5)
            self.next_button.grid_remove()  # "Sonraki" butonunu tamamen gizle
        else:
            self.next_button.grid()  # "Sonraki" butonunu g√∂ster
            self.next_button.config(state="normal")
        
        # Adƒ±ma √∂zel i√ßeriƒüi g√∂ster
        if step_number == 0:
            self.show_project_info_step()
        elif step_number == 1:
            self.show_readme_step()
        elif step_number == 2:
            self.show_ai_readme_step()
        elif step_number == 3:
            self.show_git_status_step()
        elif step_number == 4:
            self.show_branch_step()
        elif step_number == 5:
            self.show_repository_step()

    def show_project_info_step(self):
        """Adƒ±m 1: Proje bilgileri"""
        # Proje bilgileri frame
        project_frame = ttk.LabelFrame(self.content_frame, text="üìÅ Proje Bilgileri", padding="20")
        project_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 20))
        project_frame.columnconfigure(1, weight=1)
        
        # Proje klas√∂r√º se√ßimi
        folder_label = ttk.Label(project_frame, text="Proje Klas√∂r√º:", font=("Segoe UI", 10, "bold"))
        folder_label.grid(row=0, column=0, sticky=tk.W, padx=(0, 15), pady=(0, 8))
        
        self.project_path_var = tk.StringVar(value=self.current_directory)
        project_path_entry = ttk.Entry(project_frame, textvariable=self.project_path_var, 
                                     font=("Segoe UI", 10), width=45)
        project_path_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(0, 15), pady=(0, 8))
        
        browse_btn = ttk.Button(project_frame, text="üìÇ Klas√∂r Se√ß", 
                               command=self.browse_folder, style="Accent.TButton")
        browse_btn.grid(row=0, column=2, padx=(15, 0), pady=(0, 8))
        
        # Proje adƒ±
        name_label = ttk.Label(project_frame, text="Proje Adƒ±:", font=("Segoe UI", 10, "bold"))
        name_label.grid(row=1, column=0, sticky=tk.W, padx=(0, 15), pady=(0, 8))
        project_entry = ttk.Entry(project_frame, textvariable=self.project_name, 
                                font=("Segoe UI", 10), width=45)
        project_entry.grid(row=1, column=1, sticky=(tk.W, tk.E), padx=(0, 15), pady=(0, 8))
        
        # GitHub kullanƒ±cƒ± adƒ±
        user_label = ttk.Label(project_frame, text="GitHub Kullanƒ±cƒ±:", font=("Segoe UI", 10, "bold"))
        user_label.grid(row=2, column=0, sticky=tk.W, padx=(0, 15), pady=(0, 8))
        username_entry = ttk.Entry(project_frame, textvariable=self.github_username, 
                                 font=("Segoe UI", 10), width=45)
        username_entry.grid(row=2, column=1, sticky=(tk.W, tk.E), padx=(0, 15), pady=(0, 8))
        
        # Commit mesajƒ±
        commit_label = ttk.Label(project_frame, text="Commit Mesajƒ±:", font=("Segoe UI", 10, "bold"))
        commit_label.grid(row=3, column=0, sticky=tk.W, padx=(0, 15), pady=(0, 8))
        commit_entry = ttk.Entry(project_frame, textvariable=self.commit_message, 
                               font=("Segoe UI", 10), width=45)
        commit_entry.grid(row=3, column=1, sticky=(tk.W, tk.E), padx=(0, 15), pady=(0, 8))

    def show_readme_step(self):
        """Adƒ±m 2: README.md y√∂netimi"""
        readme_frame = ttk.LabelFrame(self.content_frame, text="üìñ README.md Y√∂netimi", padding="20")
        readme_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 20))
        readme_frame.columnconfigure(0, weight=1)
        
        # README se√ßenekleri - 3 se√ßenek
        readme_keep = ttk.Radiobutton(readme_frame, text="üìù Mevcut README.md'yi koru", 
                                     variable=self.readme_var, value="keep")
        readme_keep.grid(row=0, column=0, sticky=tk.W, pady=(0, 15))
        
        readme_ai = ttk.Radiobutton(readme_frame, text="ü§ñ GitAuto AI ile yeni README.md olu≈ütur", 
                                   variable=self.readme_var, value="ai")
        readme_ai.grid(row=1, column=0, sticky=tk.W, pady=(0, 15))
        
        readme_none = ttk.Radiobutton(readme_frame, text="üö´ README olmadan devam et (README.md silinecek)", 
                                     variable=self.readme_var, value="none")
        readme_none.grid(row=2, column=0, sticky=tk.W, pady=(0, 15))
        
        # README √∂nizleme butonu
        preview_btn = ttk.Button(readme_frame, text="üëÅÔ∏è README √ñnizle", 
                                command=self.preview_readme, style="Secondary.TButton")
        preview_btn.grid(row=3, column=0, pady=(15, 0))
        
        # Repository durumu kontrol√º ve baƒülama butonu
        repo_status_frame = ttk.Frame(readme_frame)
        repo_status_frame.grid(row=4, column=0, sticky=(tk.W, tk.E), pady=(20, 0))
        repo_status_frame.columnconfigure(0, weight=1)
        
        # Repository durumu etiketi - ortada
        self.repo_status_readme_label = ttk.Label(repo_status_frame, 
                                                 text="Repository durumu kontrol ediliyor...", 
                                                 font=("Segoe UI", 10))
        self.repo_status_readme_label.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 15))
        
        # Repository baƒülama butonu (sadece repository yoksa g√∂r√ºn√ºr) - ortada
        self.connect_button_readme = ttk.Button(repo_status_frame, text="üîó Repository Baƒüla", 
                                               command=self.connect_repository, style="Primary.TButton")
        self.connect_button_readme.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 15))
        
        # Repository durumunu kontrol et ve butonlarƒ± g√ºncelle
        self.update_readme_repo_status()

    def update_readme_repo_status(self):
        """README adƒ±mƒ±nda repository durumunu g√ºncelle"""
        try:
            # Widget'larƒ±n mevcut olup olmadƒ±ƒüƒ±nƒ± kontrol et
            if not hasattr(self, 'repo_status_readme_label') or not hasattr(self, 'connect_button_readme'):
                return  # Widget'lar hen√ºz olu≈üturulmamƒ±≈üsa √ßƒ±k
            
            # Widget'larƒ±n ger√ßekten mevcut olup olmadƒ±ƒüƒ±nƒ± kontrol et
            try:
                if not self.repo_status_readme_label.winfo_exists() or not self.connect_button_readme.winfo_exists():
                    return  # Widget'lar artƒ±k mevcut deƒüilse √ßƒ±k
            except tk.TclError:
                return  # Widget referans hatasƒ± durumunda √ßƒ±k
            
            # Repository durumunu ger√ßek zamanlƒ± kontrol et
            git_dir = os.path.join(self.current_directory, ".git")
            repo_exists = os.path.exists(git_dir) and os.path.isdir(git_dir)
            
            # Eƒüer .git klas√∂r√º varsa ama repository bozuksa
            if repo_exists:
                try:
                    # Git status komutu ile repository saƒülƒ±ƒüƒ±nƒ± kontrol et
                    result = subprocess.run("git status", shell=True, capture_output=True, 
                                          text=True, cwd=self.current_directory, timeout=5)
                    if result.returncode != 0:
                        repo_exists = False
                        self.log_message("‚ö†Ô∏è README: Git repository bozuk veya ge√ßersiz")
                except:
                    repo_exists = False
                    self.log_message("‚ö†Ô∏è README: Git repository eri≈üilemez durumda")
            
            if repo_exists:
                # Repository varsa
                try:
                    self.repo_status_readme_label.config(text="‚úÖ Git repository mevcut ve saƒülƒ±klƒ±", foreground="green")
                    self.connect_button_readme.grid_remove()  # Butonu gizle
                except tk.TclError:
                    pass  # Widget referans hatasƒ± durumunda sessizce devam et
            else:
                # Repository yoksa
                try:
                    self.repo_status_readme_label.config(text="‚ùå Git repository bulunamadƒ±", foreground="red")
                    self.connect_button_readme.grid()  # Butonu g√∂ster
                except tk.TclError:
                    pass  # Widget referans hatasƒ± durumunda sessizce devam et
                
        except Exception as e:
            # Widget mevcutsa hata mesajƒ±nƒ± g√∂ster
            try:
                if hasattr(self, 'repo_status_readme_label') and self.repo_status_readme_label.winfo_exists():
                    self.repo_status_readme_label.config(text="‚ùå Repository durumu kontrol edilemedi", foreground="red")
            except tk.TclError:
                pass  # Widget referans hatasƒ± durumunda sessizce devam et
            self.log_message(f"‚ùå Repository durum kontrol√º hatasƒ±: {e}")

    def check_repository_before_proceed(self):
        """README adƒ±mƒ±ndan sonra repository kontrol√º yap"""
        repo_exists = os.path.exists(os.path.join(self.current_directory, ".git"))
        
        if not repo_exists:
            result = messagebox.askyesno(
                "Repository Gerekli", 
                "‚ùå Git repository hen√ºz ba≈ülatƒ±lmamƒ±≈ü!\n\n"
                "Devam etmek i√ßin √∂nce 'Repository Baƒüla' butonunu kullanarak\n"
                "bir Git repository olu≈üturmanƒ±z gerekiyor.\n\n"
                "Repository olu≈üturmak ister misiniz?"
            )
            
            if result:
                # README adƒ±mƒ±na geri d√∂n
                self.show_step(1)
                return False
            else:
                return False
        
        return True

    def show_branch_step(self):
        """Adƒ±m 3: Branch y√∂netimi"""
        branch_frame = ttk.LabelFrame(self.content_frame, text="üåø Branch Y√∂netimi", padding="20")
        branch_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 20))
        branch_frame.columnconfigure(1, weight=1)
        
        # Branch se√ßimi
        branch_label = ttk.Label(branch_frame, text="Hedef Branch:", font=("Segoe UI", 10, "bold"))
        branch_label.grid(row=0, column=0, sticky=tk.W, padx=(0, 15), pady=(0, 8))
        
        self.branch_combo = ttk.Combobox(branch_frame, textvariable=self.selected_branch, 
                                        values=["main", "master", "develop"], width=25, 
                                        state="readonly", font=("Segoe UI", 10))
        self.branch_combo.grid(row=0, column=1, sticky=tk.W, padx=(0, 15), pady=(0, 8))
        
        refresh_btn = ttk.Button(branch_frame, text="üîÑ", command=self.refresh_branches, 
                                width=4, style="Accent.TButton")
        refresh_btn.grid(row=0, column=2, padx=(15, 0), pady=(0, 8))
        
        # Yeni branch olu≈ütur
        new_branch_label = ttk.Label(branch_frame, text="Yeni Branch:", font=("Segoe UI", 10, "bold"))
        new_branch_label.grid(row=1, column=0, sticky=tk.W, padx=(0, 15), pady=(0, 8))
        
        self.new_branch_var = tk.StringVar()
        new_branch_entry = ttk.Entry(branch_frame, textvariable=self.new_branch_var, 
                                   width=25, font=("Segoe UI", 10))
        new_branch_entry.grid(row=1, column=1, sticky=tk.W, padx=(0, 15), pady=(0, 8))
        
        create_branch_btn = ttk.Button(branch_frame, text="üå± Branch Olu≈ütur", 
                                      command=self.create_new_branch, style="Accent.TButton")
        create_branch_btn.grid(row=1, column=2, padx=(15, 0), pady=(0, 8))
        
        # Branch i≈ülemleri
        button_frame = ttk.Frame(branch_frame)
        button_frame.grid(row=2, column=0, columnspan=3, pady=(15, 0))
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        
        list_branches_btn = ttk.Button(button_frame, text="üìã Branch'leri Listele", 
                                      command=self.list_branches, style="Secondary.TButton")
        list_branches_btn.grid(row=0, column=0, padx=(0, 10))
        
        clean_btn = ttk.Button(button_frame, text="üßπ Repository Temizle", 
                              command=self.clean_repository, style="Secondary.TButton")
        clean_btn.grid(row=0, column=1, padx=(10, 0))
        
        # Branch listesini g√ºncelle
        self.refresh_branches()

    def show_git_status_step(self):
        """Adƒ±m 4: Git durumu"""
        status_frame = ttk.LabelFrame(self.content_frame, text="üîç Git Durumu", padding="20")
        status_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 20))
        status_frame.columnconfigure(1, weight=1)
        
        # Git durum etiketleri
        self.git_status_label = ttk.Label(status_frame, text="Git durumu kontrol ediliyor...", 
                                         font=("Segoe UI", 10))
        self.git_status_label.grid(row=0, column=0, columnspan=2, sticky=tk.W, pady=(0, 8))
        
        self.repo_status_label = ttk.Label(status_frame, text="Repository durumu kontrol ediliyor...", 
                                          font=("Segoe UI", 10))
        self.repo_status_label.grid(row=1, column=0, columnspan=2, sticky=tk.W, pady=(0, 8))
        
        # Git kurulum kontrol√º
        git_check_btn = ttk.Button(status_frame, text="üîç Git Durumunu Kontrol Et", 
                                  command=self.check_git_status, style="Accent.TButton")
        git_check_btn.grid(row=2, column=0, columnspan=2, pady=(15, 0))

    def show_ai_readme_step(self):
        """Adƒ±m 3: AI README Olu≈üturucu"""
        ai_frame = ttk.LabelFrame(self.content_frame, text="ü§ñ AI README Olu≈üturucu", padding="20")
        ai_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 20))
        ai_frame.columnconfigure(0, weight=1)
        
        # Gemini API Key giri≈üi
        api_key_label = ttk.Label(ai_frame, text="üîë Gemini API Key:", font=("Segoe UI", 10, "bold"))
        api_key_label.grid(row=0, column=0, sticky=tk.W, pady=(0, 5))
        
        self.gemini_api_key = tk.StringVar()
        api_key_entry = ttk.Entry(ai_frame, textvariable=self.gemini_api_key, width=50, show="*")
        api_key_entry.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 15))
        
        # AI README olu≈ütur butonu
        ai_button = ttk.Button(ai_frame, text="ü§ñ AI ile README Olu≈ütur", 
                               command=self.create_ai_readme, style="Primary.TButton")
        ai_button.grid(row=2, column=0, pady=(0, 15))
        
        # Geri d√∂n√º≈ü butonu
        back_btn = ttk.Button(ai_frame, text="‚¨ÖÔ∏è README Y√∂netimine D√∂n", 
                             command=lambda: self.show_step(1), style="Secondary.TButton")
        back_btn.grid(row=3, column=0, pady=(15, 0))
        
        # Bilgi etiketi
        info_label = ttk.Label(ai_frame, 
                              text="üí° Gemini AI ile proje kodlarƒ±nƒ± analiz edip profesyonel README.md olu≈üturur.\nüîë API Key'i https://aistudio.google.com/ adresinden alabilirsiniz.",
                              font=("Segoe UI", 10),
                              foreground="#64748b",
                              justify="center")
        info_label.grid(row=4, column=0, pady=(15, 0))

    def show_repository_step(self):
        """Adƒ±m 6: Repository i≈ülemleri"""
        repo_frame = ttk.LabelFrame(self.content_frame, text="üöÄ Repository Yayƒ±nlama", padding="20")
        repo_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 20))
        repo_frame.columnconfigure(0, weight=1)
        
        # T√ºm dosyalarƒ± yayƒ±nla butonu - Ana i≈ülem
        self.main_button = ttk.Button(repo_frame, text="üöÄ T√ºm Dosyalarƒ± Yayƒ±nla", 
                                      command=self.start_publication, style="Primary.TButton",
                                      state="normal")
        self.main_button.grid(row=0, column=0, pady=(0, 15))
        
        # Bilgi etiketi
        info_label = ttk.Label(repo_frame, 
                              text="üí° Repository baƒülama i≈ülemi README.md adƒ±mƒ±nda yapƒ±lmƒ±≈ütƒ±r.\nüöÄ ≈ûimdi t√ºm proje dosyalarƒ±nƒ± yayƒ±nlayabilirsiniz!",
                              font=("Segoe UI", 10),
                              foreground="#64748b",
                              justify="center")
        info_label.grid(row=1, column=0, pady=(15, 15))
        
        # Bitir butonu
        finish_button = ttk.Button(repo_frame, text="üèÅ Bitir ve √áƒ±k", 
                                  command=self.finish_application, style="Success.TButton")
        finish_button.grid(row=2, column=0, pady=(0, 0))

    def next_step(self):
        """Sonraki adƒ±ma ge√ß"""
        # Adƒ±m 1 (Proje Bilgileri) bitince repository kontrol√º yap
        if self.current_step == 0:  # Proje Bilgileri adƒ±mƒ±ndan sonra
            self.check_repository_status()
            self.refresh_ui_after_repo_check()
        
        # README adƒ±mƒ±ndan sonra repository kontrol√º yap
        elif self.current_step == 1:  # README adƒ±mƒ±ndan sonra
            if not self.check_repository_before_proceed():
                return
            
            readme_choice = self.readme_var.get()
            
            if readme_choice == "keep":
                # Mevcut README korunacak - √∂nce README.md dosyasƒ± var mƒ± kontrol et
                readme_path = os.path.join(self.current_directory, "README.md")
                if not os.path.exists(readme_path):
                    # README.md dosyasƒ± yoksa hata ver
                    messagebox.showerror(
                        "README Hatasƒ±", 
                        "‚ùå README.md dosyasƒ± bulunamadƒ±!\n\n"
                        "üìù 'Mevcut README.md'yi koru' se√ßeneƒüi se√ßildi ancak\n"
                        "proje klas√∂r√ºnde README.md dosyasƒ± bulunmuyor.\n\n"
                        "üí° L√ºtfen:\n"
                        "‚Ä¢ 'ü§ñ GitAuto AI ile yeni README.md olu≈ütur' se√ßeneƒüini se√ßin\n"
                        "‚Ä¢ Veya 'üö´ README olmadan devam et' se√ßeneƒüini se√ßin"
                    )
                    return  # ƒ∞lerlemeyi engelle
                
                # README.md varsa - adƒ±m 3 atlanƒ±r
                self.log_message("üìù Mevcut README korunacak - AI README adƒ±mƒ± atlanƒ±yor")
                self.show_step(3)  # Git Durumu adƒ±mƒ±na git
                return
            elif readme_choice == "none":
                # README olmadan devam et - mevcut README varsa sil, adƒ±m 3 atlanƒ±r
                self.handle_readme_none_choice()
                self.log_message("üö´ README olmadan devam ediliyor - AI README adƒ±mƒ± atlanƒ±yor")
                self.show_step(3)  # Git Durumu adƒ±mƒ±na git
                return
            elif readme_choice == "ai":
                # AI README olu≈üturulacak - normal akƒ±≈ü devam eder
                self.log_message("ü§ñ AI README olu≈üturulacak - AI adƒ±mƒ±na gidiliyor")
                # Normal akƒ±≈ü devam eder (adƒ±m 3'e git)
            else:
                # Varsayƒ±lan olarak mevcut README koru
                self.readme_var.set("keep")
                self.log_message("üìù Varsayƒ±lan se√ßim: Mevcut README korunacak")
                self.show_step(3)
                return
        
        if self.current_step < self.total_steps - 1:
            self.show_step(self.current_step + 1)

    def create_ai_readme(self):
        """Gemini AI ile README olu≈ütur"""
        try:
            api_key = self.gemini_api_key.get().strip()
            if not api_key:
                messagebox.showerror("Hata", "Gemini API Key gerekli!")
                return
            
            if not self.current_directory:
                messagebox.showerror("Hata", "√ñnce proje klas√∂r√º se√ßin!")
                return
            
            # AI README olu≈üturma i≈ülemini ba≈ülat
            self.log_message("ü§ñ AI README olu≈üturma ba≈ülatƒ±lƒ±yor...")
            
            # Thread'de √ßalƒ±≈ütƒ±r
            threading.Thread(target=self.create_ai_readme_worker, args=(api_key,), daemon=True).start()
            
        except Exception as e:
            error_msg = str(e)
            self.log_message(f"‚ùå AI README olu≈üturma hatasƒ±: {error_msg}")
            messagebox.showerror("Hata", f"AI README olu≈üturma hatasƒ±:\n{error_msg}")

    def create_ai_readme_worker(self, api_key):
        """AI README olu≈üturma i≈ülemi - arka planda √ßalƒ±≈üƒ±r"""
        try:
            self.log_message("üîç Proje dosyalarƒ± analiz ediliyor...")
            
            # Proje analizi yap
            project_analysis = self.analyze_project_for_ai()
            
            self.log_message("ü§ñ Gemini AI'ya g√∂nderiliyor...")
            
            # Gemini API √ßaƒürƒ±sƒ±
            readme_content = self.call_gemini_api(api_key, project_analysis)
            
            if readme_content:
                # Mevcut README varsa yedekle
                readme_path = os.path.join(self.current_directory, "README.md")
                backup_path = os.path.join(self.current_directory, "README.md.backup")
                
                if os.path.exists(readme_path):
                    # Mevcut README'yi yedekle
                    import shutil
                    shutil.copy2(readme_path, backup_path)
                    self.log_message("üíæ Mevcut README.md yedeklendi (README.md.backup)")
                
                # Yeni AI README olu≈ütur
                with open(readme_path, "w", encoding="utf-8") as f:
                    f.write(readme_content)
                
                self.log_message("‚úÖ AI README ba≈üarƒ±yla olu≈üturuldu!")
                
                # Ba≈üarƒ± mesajƒ± g√∂ster
                backup_info = "\nüíæ Mevcut README yedeklendi (README.md.backup)" if os.path.exists(backup_path) else ""
                self.root.after(0, lambda: messagebox.showinfo(
                    "Ba≈üarƒ±lƒ±! üéâ",
                    "ü§ñ AI README ba≈üarƒ±yla olu≈üturuldu!\n\n"
                    "üìù README.md dosyasƒ± proje klas√∂r√ºne kaydedildi." + backup_info + "\n"
                    "üí° ≈ûimdi README.md Y√∂netimi adƒ±mƒ±nda d√ºzenleyebilirsiniz."
                ))
                
                # README adƒ±mƒ±na git
                self.root.after(0, lambda: self.show_step(1))
            else:
                raise Exception("Gemini API'den yanƒ±t alƒ±namadƒ±")
                
        except Exception as e:
            error_msg = str(e)
            self.log_message(f"‚ùå AI README olu≈üturma hatasƒ±: {error_msg}")
            self.root.after(0, lambda msg=error_msg: messagebox.showerror("Hata", f"AI README olu≈üturma hatasƒ±:\n{msg}"))

    def analyze_project_for_ai(self):
        """Proje dosyalarƒ±nƒ± AI analizi i√ßin hazƒ±rla - DETAYLI ANALƒ∞Z"""
        try:
            analysis = {
                "project_name": self.project_name.get().strip(),
                "files": [],
                "folders": [],
                "technologies": [],
                "config_files": [],
                "main_files": [],
                "code_analysis": {
                    "imports": [],
                    "functions": [],
                    "classes": [],
                    "dependencies": [],
                    "variables": [],
                    "comments": [],
                    "project_purpose": ""
                }
            }
            
            self.log_message("üîç Proje dosyalarƒ± detaylƒ± analiz ediliyor...")
            
            # Dosya ve klas√∂rleri tara
            for root, dirs, files in os.walk(self.current_directory):
                # .git klas√∂r√ºn√º atla
                if '.git' in root:
                    continue
                    
                # Klas√∂r yapƒ±sƒ±
                rel_path = os.path.relpath(root, self.current_directory)
                if rel_path != '.':
                    analysis["folders"].append(rel_path)
                
                # Dosyalarƒ± analiz et
                for file in files:
                    file_path = os.path.join(root, file)
                    rel_file_path = os.path.join(rel_path, file)
                    
                    # Dosya bilgisi
                    file_info = {
                        "name": file,
                        "path": rel_file_path,
                        "size": os.path.getsize(file_path),
                        "extension": os.path.splitext(file)[1]
                    }
                    
                    # Teknoloji tespiti
                    if file in ['package.json', 'requirements.txt', 'pom.xml', 'build.gradle', 'Cargo.toml', 'go.mod', 'composer.json', 'Gemfile']:
                        analysis["config_files"].append(file_info)
                        analysis["technologies"].append(self.detect_technology_from_config(file))
                        # Konfig√ºrasyon dosyasƒ± i√ßeriƒüini analiz et
                        config_analysis = self.analyze_config_file(file_path, file)
                        if config_analysis:
                            analysis["code_analysis"]["dependencies"].extend(config_analysis)
                    elif file_info["extension"] in ['.py', '.js', '.ts', '.java', '.cpp', '.cs', '.php', '.rb', '.go', '.rs', '.vue', '.jsx', '.tsx']:
                        analysis["main_files"].append(file_info)
                        analysis["technologies"].append(self.detect_technology_from_extension(file_info["extension"]))
                        
                        # Kod dosyasƒ± i√ßeriƒüini DETAYLI analiz et
                        self.log_message(f"üìñ Analiz ediliyor: {rel_file_path}")
                        code_analysis = self.analyze_code_file_detailed(file_path, file_info["extension"])
                        if code_analysis:
                            analysis["code_analysis"]["imports"].extend(code_analysis.get("imports", []))
                            analysis["code_analysis"]["functions"].extend(code_analysis.get("functions", []))
                            analysis["code_analysis"]["classes"].extend(code_analysis.get("classes", []))
                            analysis["code_analysis"]["variables"].extend(code_analysis.get("variables", []))
                            analysis["code_analysis"]["comments"].extend(code_analysis.get("comments", []))
                    
                    analysis["files"].append(file_info)
            
            # Teknolojileri benzersiz yap
            analysis["technologies"] = list(set(analysis["technologies"]))
            
            # Proje amacƒ±nƒ± tespit et
            analysis["code_analysis"]["project_purpose"] = self.detect_project_purpose(analysis)
            
            self.log_message(f"‚úÖ Analiz tamamlandƒ±: {len(analysis['main_files'])} kod dosyasƒ±, {len(analysis['code_analysis']['imports'])} import bulundu")
            
            return analysis
            
        except Exception as e:
            self.log_message(f"‚ùå Proje analizi hatasƒ±: {e}")
            return None

    def detect_technology_from_config(self, filename):
        """Konfig√ºrasyon dosyasƒ±ndan teknoloji tespit et"""
        tech_map = {
            'package.json': 'Node.js/JavaScript',
            'requirements.txt': 'Python',
            'pom.xml': 'Java Maven',
            'build.gradle': 'Java Gradle',
            'Cargo.toml': 'Rust',
            'go.mod': 'Go',
            'composer.json': 'PHP',
            'Gemfile': 'Ruby'
        }
        return tech_map.get(filename, 'Unknown')

    def detect_technology_from_extension(self, extension):
        """Dosya uzantƒ±sƒ±ndan teknoloji tespit et"""
        tech_map = {
            '.py': 'Python',
            '.js': 'JavaScript',
            '.ts': 'TypeScript',
            '.java': 'Java',
            '.cpp': 'C++',
            '.cs': 'C#',
            '.php': 'PHP',
            '.rb': 'Ruby',
            '.go': 'Go',
            '.rs': 'Rust'
        }
        return tech_map.get(extension, 'Unknown')

    def analyze_config_file(self, file_path, filename):
        """Konfig√ºrasyon dosyasƒ±nƒ±n i√ßeriƒüini analiz et"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            dependencies = []
            
            if filename == 'package.json':
                # Node.js dependencies
                import json
                try:
                    data = json.loads(content)
                    if 'dependencies' in data:
                        dependencies.extend(list(data['dependencies'].keys()))
                    if 'devDependencies' in data:
                        dependencies.extend(list(data['devDependencies'].keys()))
                except:
                    pass
                    
            elif filename == 'requirements.txt':
                # Python dependencies
                for line in content.split('\n'):
                    line = line.strip()
                    if line and not line.startswith('#') and not line.startswith('--'):
                        # Sadece paket adƒ±nƒ± al (versiyon bilgisini √ßƒ±kar)
                        package = line.split('==')[0].split('>=')[0].split('<=')[0].split('~=')[0].split('!=')[0]
                        dependencies.append(package.strip())
                        
            elif filename == 'pom.xml':
                # Java Maven dependencies
                import re
                dependencies = re.findall(r'<artifactId>([^<]+)</artifactId>', content)
                
            elif filename == 'build.gradle':
                # Java Gradle dependencies
                import re
                dependencies = re.findall(r"implementation\s+['\"]([^'\"]+)['\"]", content)
                dependencies.extend(re.findall(r"compile\s+['\"]([^'\"]+)['\"]", content))
                
            elif filename == 'Cargo.toml':
                # Rust dependencies
                import re
                dependencies = re.findall(r'^([a-zA-Z0-9_-]+)\s*=', content, re.MULTILINE)
                
            elif filename == 'go.mod':
                # Go dependencies
                import re
                dependencies = re.findall(r'^require\s+([a-zA-Z0-9\._-]+)', content, re.MULTILINE)
                
            elif filename == 'composer.json':
                # PHP dependencies
                import json
                try:
                    data = json.loads(content)
                    if 'require' in data:
                        dependencies.extend(list(data['require'].keys()))
                except:
                    pass
                    
            elif filename == 'Gemfile':
                # Ruby dependencies
                import re
                dependencies = re.findall(r"gem\s+['\"]([^'\"]+)['\"]", content)
            
            return dependencies
            
        except Exception as e:
            return []

    def analyze_code_file(self, file_path, extension):
        """Kod dosyasƒ±nƒ±n i√ßeriƒüini analiz et"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            analysis = {
                "imports": [],
                "functions": [],
                "classes": []
            }
            
            import re
            
            if extension == '.py':
                # Python analizi
                # Import satƒ±rlarƒ±
                imports = re.findall(r'^(?:from|import)\s+([\w\s,\.]+)', content, re.MULTILINE)
                analysis["imports"] = [imp.strip() for imp in imports if imp.strip()]
                
                # Fonksiyon tanƒ±mlarƒ±
                functions = re.findall(r'^def\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(', content, re.MULTILINE)
                analysis["functions"] = functions
                
                # Class tanƒ±mlarƒ±
                classes = re.findall(r'^class\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:\(|:)', content, re.MULTILINE)
                analysis["classes"] = classes
                
            elif extension in ['.js', '.ts', '.jsx', '.tsx']:
                # JavaScript/TypeScript analizi
                # Import/require satƒ±rlarƒ±
                imports = re.findall(r'^(?:import|require|from)\s+([\w\s,\.\{\}]+)', content, re.MULTILINE)
                analysis["imports"] = [imp.strip() for imp in imports if imp.strip()]
                
                # Fonksiyon tanƒ±mlarƒ±
                functions = re.findall(r'(?:function\s+([a-zA-Z_][a-zA-Z0-9_]*)|const\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*\(|let\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*\()', content)
                # Regex gruplarƒ±ndan fonksiyon adlarƒ±nƒ± √ßƒ±kar
                func_names = []
                for match in functions:
                    func_names.extend([name for name in match if name])
                analysis["functions"] = func_names
                
                # Class tanƒ±mlarƒ±
                classes = re.findall(r'class\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:extends|implements|\{)', content)
                analysis["classes"] = classes
                
            elif extension == '.java':
                # Java analizi
                # Import satƒ±rlarƒ±
                imports = re.findall(r'^import\s+([\w\.]+)', content, re.MULTILINE)
                analysis["imports"] = imports
                
                # Fonksiyon tanƒ±mlarƒ±
                functions = re.findall(r'(?:public|private|protected|static)?\s*(?:final)?\s*(?:[a-zA-Z<>\[\]]+)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(', content)
                analysis["functions"] = functions
                
                # Class tanƒ±mlarƒ±
                classes = re.findall(r'class\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:extends|implements|\{)', content)
                analysis["classes"] = classes
                
            elif extension == '.cpp':
                # C++ analizi
                # Include satƒ±rlarƒ±
                imports = re.findall(r'^#include\s+[<"]([^>"]+)[>"]', content, re.MULTILINE)
                analysis["imports"] = imports
                
                # Fonksiyon tanƒ±mlarƒ±
                functions = re.findall(r'([a-zA-Z_][a-zA-Z0-9_]*)\s+[a-zA-Z_][a-zA-Z0-9_]*\s*\([^)]*\)\s*\{', content)
                analysis["functions"] = functions
                
                # Class tanƒ±mlarƒ±
                classes = re.findall(r'class\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:\{|:)', content)
                analysis["classes"] = classes
                
            elif extension == '.php':
                # PHP analizi
                # Use satƒ±rlarƒ±
                imports = re.findall(r'^use\s+([\w\\]+)', content, re.MULTILINE)
                analysis["imports"] = imports
                
                # Fonksiyon tanƒ±mlarƒ±
                functions = re.findall(r'function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(', content)
                analysis["functions"] = functions
                
                # Class tanƒ±mlarƒ±
                classes = re.findall(r'class\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:extends|implements|\{)', content)
                analysis["classes"] = classes
                
            elif extension == '.go':
                # Go analizi
                # Import satƒ±rlarƒ±
                imports = re.findall(r'^import\s+([\w\s"\.]+)', content, re.MULTILINE)
                analysis["imports"] = [imp.strip() for imp in imports if imp.strip()]
                
                # Fonksiyon tanƒ±mlarƒ±
                functions = re.findall(r'func\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(', content)
                analysis["functions"] = functions
                
                # Struct tanƒ±mlarƒ±
                classes = re.findall(r'type\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+struct', content)
                analysis["classes"] = classes
                
            elif extension == '.rs':
                # Rust analizi
                # Use satƒ±rlarƒ±
                imports = re.findall(r'^use\s+([\w\s:]+)', content, re.MULTILINE)
                analysis["imports"] = [imp.strip() for imp in imports if imp.strip()]
                
                # Fonksiyon tanƒ±mlarƒ±
                functions = re.findall(r'fn\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(', content)
                analysis["functions"] = functions
                
                # Struct tanƒ±mlarƒ±
                classes = re.findall(r'struct\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\{', content)
                analysis["classes"] = classes
            
            return analysis
            
        except Exception as e:
            return {}

    def analyze_code_file_detailed(self, file_path, extension):
        """Kod dosyasƒ±nƒ±n i√ßeriƒüini DETAYLI analiz et - Ger√ßek dosya okuma"""
        try:
            # Dosyayƒ± UTF-8 ile oku
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            analysis = {
                "imports": [],
                "functions": [],
                "classes": [],
                "variables": [],
                "comments": []
            }
            
            import re
            
            if extension == '.py':
                # Python DETAYLI analizi
                # Import satƒ±rlarƒ±
                imports = re.findall(r'^(?:from|import)\s+([\w\s,\.]+)', content, re.MULTILINE)
                analysis["imports"] = [imp.strip() for imp in imports if imp.strip()]
                
                # Fonksiyon tanƒ±mlarƒ±
                functions = re.findall(r'^def\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(', content, re.MULTILINE)
                analysis["functions"] = functions
                
                # Class tanƒ±mlarƒ±
                classes = re.findall(r'^class\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:\(|:)', content, re.MULTILINE)
                analysis["classes"] = classes
                
                # √ñnemli deƒüi≈ükenler
                variables = re.findall(r'^([A-Z_][A-Z0-9_]*)\s*=', content, re.MULTILINE)
                analysis["variables"] = [var for var in variables if len(var) > 2]
                
                # Yorumlar
                comments = re.findall(r'#\s*(.+)', content)
                analysis["comments"] = [comment.strip() for comment in comments if len(comment.strip()) > 10]
                
            elif extension in ['.js', '.ts', '.jsx', '.tsx']:
                # JavaScript/TypeScript DETAYLI analizi
                # Import/require satƒ±rlarƒ±
                imports = re.findall(r'^(?:import|require|from)\s+([\w\s,\.\{\}]+)', content, re.MULTILINE)
                analysis["imports"] = [imp.strip() for imp in imports if imp.strip()]
                
                # Fonksiyon tanƒ±mlarƒ±
                functions = re.findall(r'(?:function\s+([a-zA-Z_][a-zA-Z0-9_]*)|const\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*\(|let\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*\()', content)
                # Regex gruplarƒ±ndan fonksiyon adlarƒ±nƒ± √ßƒ±kar
                func_names = []
                for match in functions:
                    func_names.extend([name for name in match if name])
                analysis["functions"] = func_names
                
                # Class tanƒ±mlarƒ±
                classes = re.findall(r'class\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:extends|implements|\{)', content)
                analysis["classes"] = classes
                
                # √ñnemli deƒüi≈ükenler
                variables = re.findall(r'^(?:const|let|var)\s+([A-Z_][A-Z0-9_]*)\s*=', content, re.MULTILINE)
                analysis["variables"] = [var for var in variables if len(var) > 2]
                
                # Yorumlar
                comments = re.findall(r'//\s*(.+)|/\*\s*(.+?)\*/', content, re.DOTALL)
                analysis["comments"] = []
                for comment in comments:
                    if comment[0]:
                        analysis["comments"].append(comment[0].strip())
                    if comment[1]:
                        analysis["comments"].append(comment[1].strip())
                analysis["comments"] = [comment for comment in analysis["comments"] if len(comment) > 10]
                
            elif extension == '.java':
                # Java DETAYLI analizi
                # Import satƒ±rlarƒ±
                imports = re.findall(r'^import\s+([\w\.]+)', content, re.MULTILINE)
                analysis["imports"] = imports
                
                # Fonksiyon tanƒ±mlarƒ±
                functions = re.findall(r'(?:public|private|protected|static)?\s*(?:final)?\s*(?:[a-zA-Z<>\[\]]+)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(', content)
                analysis["functions"] = functions
                
                # Class tanƒ±mlarƒ±
                classes = re.findall(r'class\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:extends|implements|\{)', content)
                analysis["classes"] = classes
                
                # √ñnemli deƒüi≈ükenler
                variables = re.findall(r'^(?:public|private|protected|static)?\s*(?:final)?\s*(?:[a-zA-Z<>\[\]]+)\s+([A-Z_][A-Z0-9_]*)\s*;', content, re.MULTILINE)
                analysis["variables"] = [var for var in variables if len(var) > 2]
                
                # Yorumlar
                comments = re.findall(r'//\s*(.+)|/\*\s*(.+?)\*/', content, re.DOTALL)
                analysis["comments"] = []
                for comment in comments:
                    if comment[0]:
                        analysis["comments"].append(comment[0].strip())
                    if comment[1]:
                        analysis["comments"].append(comment[1].strip())
                analysis["comments"] = [comment for comment in analysis["comments"] if len(comment) > 10]
                
            elif extension == '.cpp':
                # C++ DETAYLI analizi
                # Include satƒ±rlarƒ±
                imports = re.findall(r'^#include\s+[<"]([^>"]+)[>"]', content, re.MULTILINE)
                analysis["imports"] = imports
                
                # Fonksiyon tanƒ±mlarƒ±
                functions = re.findall(r'([a-zA-Z_][a-zA-Z0-9_]*)\s+[a-zA-Z_][a-zA-Z0-9_]*\s*\([^)]*\)\s*\{', content)
                analysis["functions"] = functions
                
                # Class tanƒ±mlarƒ±
                classes = re.findall(r'class\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:\{|:)', content)
                analysis["classes"] = classes
                
                # √ñnemli deƒüi≈ükenler
                variables = re.findall(r'^(?:int|double|float|string|char|bool)\s+([A-Z_][A-Z0-9_]*)\s*;', content, re.MULTILINE)
                analysis["variables"] = [var for var in variables if len(var) > 2]
                
                # Yorumlar
                comments = re.findall(r'//\s*(.+)|/\*\s*(.+?)\*/', content, re.DOTALL)
                analysis["comments"] = []
                for comment in comments:
                    if comment[0]:
                        analysis["comments"].append(comment[0].strip())
                    if comment[1]:
                        analysis["comments"].append(comment[1].strip())
                analysis["comments"] = [comment for comment in analysis["comments"] if len(comment) > 10]
                
            elif extension == '.php':
                # PHP DETAYLI analizi
                # Use satƒ±rlarƒ±
                imports = re.findall(r'^use\s+([\w\\]+)', content, re.MULTILINE)
                analysis["imports"] = imports
                
                # Fonksiyon tanƒ±mlarƒ±
                functions = re.findall(r'function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(', content)
                analysis["functions"] = functions
                
                # Class tanƒ±mlarƒ±
                classes = re.findall(r'class\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:extends|implements|\{)', content)
                analysis["classes"] = classes
                
                # √ñnemli deƒüi≈ükenler
                variables = re.findall(r'^\$([A-Z_][A-Z0-9_]*)\s*=', content, re.MULTILINE)
                analysis["variables"] = [var for var in variables if len(var) > 2]
                
                # Yorumlar
                comments = re.findall(r'//\s*(.+)|#\s*(.+)|/\*\s*(.+?)\*/', content, re.DOTALL)
                analysis["comments"] = []
                for comment in comments:
                    if comment[0]:
                        analysis["comments"].append(comment[0].strip())
                    if comment[1]:
                        analysis["comments"].append(comment[1].strip())
                    if comment[2]:
                        analysis["comments"].append(comment[2].strip())
                analysis["comments"] = [comment for comment in analysis["comments"] if len(comment) > 10]
                
            elif extension == '.go':
                # Go DETAYLI analizi
                # Import satƒ±rlarƒ±
                imports = re.findall(r'^import\s+([\w\s"\.]+)', content, re.MULTILINE)
                analysis["imports"] = [imp.strip() for imp in imports if imp.strip()]
                
                # Fonksiyon tanƒ±mlarƒ±
                functions = re.findall(r'func\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(', content)
                analysis["functions"] = functions
                
                # Struct tanƒ±mlarƒ±
                classes = re.findall(r'type\s+([a-zA-Z_][a-zA-Z0-9_]*)\s+struct', content)
                analysis["classes"] = classes
                
                # √ñnemli deƒüi≈ükenler
                variables = re.findall(r'^var\s+([A-Z_][A-Z0-9_]*)\s*', content, re.MULTILINE)
                analysis["variables"] = [var for var in variables if len(var) > 2]
                
                # Yorumlar
                comments = re.findall(r'//\s*(.+)|/\*\s*(.+?)\*/', content, re.DOTALL)
                analysis["comments"] = []
                for comment in comments:
                    if comment[0]:
                        analysis["comments"].append(comment[0].strip())
                    if comment[1]:
                        analysis["comments"].append(comment[1].strip())
                analysis["comments"] = [comment for comment in analysis["comments"] if len(comment) > 10]
                
            elif extension == '.rs':
                # Rust DETAYLI analizi
                # Use satƒ±rlarƒ±
                imports = re.findall(r'^use\s+([\w\s:]+)', content, re.MULTILINE)
                analysis["imports"] = [imp.strip() for imp in imports if imp.strip()]
                
                # Fonksiyon tanƒ±mlarƒ±
                functions = re.findall(r'fn\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(', content)
                analysis["functions"] = functions
                
                # Struct tanƒ±mlarƒ±
                classes = re.findall(r'struct\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\{', content)
                analysis["classes"] = classes
                
                # √ñnemli deƒüi≈ükenler
                variables = re.findall(r'^let\s+([A-Z_][A-Z0-9_]*)\s*:', content, re.MULTILINE)
                analysis["variables"] = [var for var in variables if len(var) > 2]
                
                # Yorumlar
                comments = re.findall(r'//\s*(.+)|/\*\s*(.+?)\*/', content, re.DOTALL)
                analysis["comments"] = []
                for comment in comments:
                    if comment[0]:
                        analysis["comments"].append(comment[0].strip())
                    if comment[1]:
                        analysis["comments"].append(comment[1].strip())
                analysis["comments"] = [comment for comment in analysis["comments"] if len(comment) > 10]
            
            return analysis
            
        except Exception as e:
            return {}

    def handle_readme_none_choice(self):
        """README olmadan devam et se√ßeneƒüi i≈ülenir"""
        try:
            readme_path = os.path.join(self.current_directory, "README.md")
            if os.path.exists(readme_path):
                # Mevcut README varsa sil
                os.remove(readme_path)
                self.log_message("üóëÔ∏è Mevcut README.md dosyasƒ± silindi")
            else:
                self.log_message("‚ÑπÔ∏è README.md dosyasƒ± bulunamadƒ± - zaten yok")
        except Exception as e:
            self.log_message(f"‚ö†Ô∏è README silme hatasƒ±: {e}")

    def detect_project_purpose(self, analysis):
        """Proje amacƒ±nƒ± tespit et"""
        try:
            purpose_indicators = {
                "web": ["flask", "django", "express", "react", "vue", "angular", "html", "css", "web"],
                "api": ["api", "rest", "graphql", "endpoint", "controller", "route"],
                "desktop": ["tkinter", "pyqt", "wx", "electron", "javafx", "swing"],
                "mobile": ["react-native", "flutter", "kotlin", "swift", "mobile"],
                "data": ["pandas", "numpy", "matplotlib", "scikit", "tensorflow", "pytorch", "data"],
                "game": ["pygame", "unity", "unreal", "game", "sprite", "collision"],
                "cli": ["click", "argparse", "typer", "command", "cli", "terminal"],
                "library": ["setup.py", "pyproject.toml", "lib", "module", "package"]
            }
            
            # Teknoloji ve dependency'leri birle≈ütir
            all_techs = analysis["technologies"] + analysis["code_analysis"]["dependencies"]
            all_techs = [tech.lower() for tech in all_techs]
            
            # Ama√ß skorlarƒ±
            scores = {}
            for purpose, indicators in purpose_indicators.items():
                score = sum(1 for indicator in indicators if any(indicator in tech for tech in all_techs))
                scores[purpose] = score
            
            # En y√ºksek skorlu amacƒ± d√∂nd√ºr
            if scores:
                best_purpose = max(scores, key=scores.get)
                if scores[best_purpose] > 0:
                    return best_purpose
            
            return "general"
            
        except Exception as e:
            return "general"

    def call_gemini_api(self, api_key, project_analysis):
        """Gemini API'yi √ßaƒüƒ±r ve README olu≈ütur"""
        try:
            import requests
            
            # Gemini API endpoint - g√ºncel model adƒ± ve API versiyonu
            url = "https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent"
            
            # Proje analizi metni - DETAYLI ANALƒ∞Z
            analysis_text = f"""
Proje: {project_analysis['project_name']}

üîç TEKNOLOJƒ∞ ANALƒ∞Zƒ∞:
Teknolojiler: {', '.join(project_analysis['technologies'])}
Proje Amacƒ±: {project_analysis['code_analysis']['project_purpose']}

üì¶ BAƒûIMLILIKLAR:
Konfig√ºrasyon Dosyalarƒ±: {[f['name'] for f in project_analysis['config_files']]}
Dependencies: {', '.join(project_analysis['code_analysis']['dependencies'][:20])}

üìÅ DOSYA YAPISI:
Ana Dosyalar: {[f['name'] for f in project_analysis['main_files'][:15]]}
Klas√∂r Yapƒ±sƒ±: {project_analysis['folders'][:25]}

üíª DETAYLI KOD ANALƒ∞Zƒ∞:
Import/Use Satƒ±rlarƒ±: {', '.join(project_analysis['code_analysis']['imports'][:30])}
Fonksiyonlar: {', '.join(project_analysis['code_analysis']['functions'][:20])}
Class/Struct'lar: {', '.join(project_analysis['code_analysis']['classes'][:15])}
√ñnemli Deƒüi≈ükenler: {', '.join(project_analysis['code_analysis']['variables'][:10])}
Kod Yorumlarƒ±: {', '.join(project_analysis['code_analysis']['comments'][:5])}

Bu DETAYLI kod analizi sonucunda, proje i√ßin PROFESYONEL ve KAPSAMLI bir README.md olu≈ütur.

README ≈üunlarƒ± i√ßersin:
1. üéØ Proje ba≈ülƒ±ƒüƒ± ve detaylƒ± a√ßƒ±klamasƒ± (proje amacƒ±na ve kod analizinden √ßƒ±kan bilgileri g√∂re)
2. üõ†Ô∏è Teknoloji stack'i ve kullanƒ±lan k√ºt√ºphaneler (import'lardan √ßƒ±kar)
3. üìã √ñzellikler listesi (fonksiyon ve class'lardan √ßƒ±kar)
4. üöÄ Kurulum talimatlarƒ± (dependencies'e g√∂re)
5. üí° Kullanƒ±m √∂rnekleri (ana fonksiyonlardan)
6. üìÅ Klas√∂r yapƒ±sƒ± ve dosya organizasyonu
7. üîß Konfig√ºrasyon se√ßenekleri

README'yi sadece markdown formatƒ±nda d√∂nd√ºr, ek a√ßƒ±klama ekleme.
README profesyonel, a√ßƒ±k ve anla≈üƒ±lƒ±r olsun.
Kod analizinden √ßƒ±kan bilgileri kullanarak ger√ßek proje yapƒ±sƒ±nƒ± yansƒ±t.
"""
            
            # API isteƒüi
            headers = {
                "Content-Type": "application/json"
            }
            
            data = {
                "contents": [{
                    "parts": [{
                        "text": analysis_text
                    }]
                }]
            }
            
            params = {
                "key": api_key
            }
            
            response = requests.post(url, headers=headers, json=data, params=params)
            
            if response.status_code == 200:
                result = response.json()
                if 'candidates' in result and len(result['candidates']) > 0:
                    content = result['candidates'][0]['content']['parts'][0]['text']
                    return content
                else:
                    raise Exception("API yanƒ±tƒ±nda i√ßerik bulunamadƒ±")
            else:
                raise Exception(f"API hatasƒ±: {response.status_code} - {response.text}")
                
        except ImportError:
            raise Exception("requests k√ºt√ºphanesi gerekli! 'pip install requests' komutu ile y√ºkleyin.")
        except Exception as e:
            raise Exception(f"Gemini API hatasƒ±: {e}")

    def finish_application(self):
        """Uygulamayƒ± bitir ve √ßƒ±k"""
        if messagebox.askyesno("üèÅ Bitir", 
                               "GitAuto'yu kapatmak istediƒüinizden emin misiniz?\n\n"
                               "T√ºm i≈ülemler tamamlandƒ±."):
            self.root.destroy()

    def previous_step(self):
        """√ñnceki adƒ±ma ge√ß"""
        if self.current_step > 0:
            self.show_step(self.current_step - 1)



    def preview_readme(self):
        """README.md √∂nizlemesi g√∂ster"""
        readme_path = os.path.join(self.current_directory, "README.md")
        if os.path.exists(readme_path):
            try:
                with open(readme_path, "r", encoding="utf-8") as f:
                    content = f.read()
                
                # √ñnizleme penceresi
                preview_window = tk.Toplevel(self.root)
                preview_window.title("README.md √ñnizleme")
                preview_window.geometry("600x400")
                preview_window.configure(bg="#ffffff")
                
                # ƒ∞√ßerik
                text_widget = scrolledtext.ScrolledText(preview_window, 
                                                      font=("Consolas", 10),
                                                      bg="#f8fafc", fg="#1e293b")
                text_widget.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
                text_widget.insert(tk.END, content)
                text_widget.config(state=tk.DISABLED)
                
            except Exception as e:
                messagebox.showerror("Hata", f"README.md okunamadƒ±:\n{e}")
        else:
            messagebox.showinfo("Bilgi", "README.md dosyasƒ± bulunamadƒ±.")

    def go_to_ai_readme(self):
        """AI README olu≈üturma adƒ±mƒ±na git"""
        try:
            # Proje bilgilerinin dolu olup olmadƒ±ƒüƒ±nƒ± kontrol et
            if not self.project_name.get().strip():
                messagebox.showerror("Hata", "√ñnce Adƒ±m 1'de proje adƒ±nƒ± girin!")
                return
            
            if not self.current_directory:
                messagebox.showerror("Hata", "√ñnce Adƒ±m 1'de proje klas√∂r√ºn√º se√ßin!")
                return
            
            # AI README adƒ±mƒ±na git (Adƒ±m 3)
            self.show_step(2)
            
        except Exception as e:
            messagebox.showerror("Hata", f"AI README adƒ±mƒ±na gidilemedi:\n{e}")

    def check_git_status(self):
        """Git durumunu kontrol et - ger√ßek zamanlƒ±"""
        try:
            # Git kurulum kontrol√º
            result = subprocess.run("git --version", shell=True, capture_output=True, text=True)
            self.git_installed = result.returncode == 0
            
            # Git durumu etiketini g√ºncelle (eƒüer varsa)
            if hasattr(self, 'git_status_label'):
                try:
                    if self.git_status_label.winfo_exists():
                        if self.git_installed:
                            self.git_status_label.config(text="‚úÖ Git kurulu ve hazƒ±r", foreground="green")
                        else:
                            self.git_status_label.config(text="‚ùå Git kurulu deƒüil", foreground="red")
                except tk.TclError:
                    pass  # Widget referans hatasƒ± durumunda sessizce devam et
            
            # Repository kontrol√º - ger√ßek zamanlƒ±
            git_dir = os.path.join(self.current_directory, ".git")
            self.git_repo_exists = os.path.exists(git_dir) and os.path.isdir(git_dir)
            
            # Eƒüer .git klas√∂r√º varsa ama bo≈üsa (bozuk repository)
            if os.path.exists(git_dir) and os.path.isdir(git_dir):
                try:
                    # Git status komutu ile repository saƒülƒ±ƒüƒ±nƒ± kontrol et
                    result = subprocess.run("git status", shell=True, capture_output=True, 
                                          text=True, cwd=self.current_directory, timeout=5)
                    if result.returncode != 0:
                        self.git_repo_exists = False
                        self.log_message("‚ö†Ô∏è Git repository bozuk veya ge√ßersiz")
                except:
                    self.git_repo_exists = False
                    self.log_message("‚ö†Ô∏è Git repository eri≈üilemez durumda")
            
            # Repository durumu etiketini g√ºncelle (eƒüer varsa)
            if hasattr(self, 'repo_status_label'):
                try:
                    if self.repo_status_label.winfo_exists():
                        if self.git_repo_exists:
                            self.repo_status_label.config(text="‚úÖ Git repository mevcut", foreground="green")
                        else:
                            self.repo_status_label.config(text="‚ùå Git repository bulunamadƒ±", foreground="red")
                except tk.TclError:
                    pass  # Widget referans hatasƒ± durumunda sessizce devam et
            
            # Yayƒ±n butonu durumunu g√ºncelle
            if self.git_repo_exists:
                # Eƒüer repository zaten mevcutsa yayƒ±n butonunu aktif hale getir
                if hasattr(self, 'main_button'):
                    try:
                        if self.main_button.winfo_exists():
                            self.root.after(0, lambda: self.main_button.config(state="normal"))
                    except tk.TclError:
                        pass  # Widget referans hatasƒ± durumunda sessizce devam et
                        
                self.log_message("‚úÖ Repository mevcut - Yayƒ±nlama aktif")
            else:
                # Repository yoksa yayƒ±n butonunu devre dƒ±≈üƒ± bƒ±rak
                if hasattr(self, 'main_button'):
                    try:
                        if self.main_button.winfo_exists():
                            self.root.after(0, lambda: self.main_button.config(state="disabled"))
                    except tk.TclError:
                        pass  # Widget referans hatasƒ± durumunda sessizce devam et
                        
                self.log_message("‚ùå Repository bulunamadƒ± - Yayƒ±nlama devre dƒ±≈üƒ±")
            
            # README adƒ±mƒ±ndaki repository durumunu g√ºncelle (eƒüer varsa)
            if hasattr(self, 'update_readme_repo_status'):
                try:
                    self.update_readme_repo_status()
                except Exception as e:
                    # Hata durumunda sadece log'a yaz, uygulamayƒ± durdurma
                    self.log_message(f"‚ö†Ô∏è README repository durumu g√ºncellenirken hata: {e}")
                    
        except Exception as e:
            self.log_message(f"‚ùå Git durum kontrol√º hatasƒ±: {e}")

    def log_message(self, message):
        """Log mesajƒ± ekle"""
        self.log_queue.put(message)

    def update_log(self):
        """Log mesajlarƒ±nƒ± g√ºncelle"""
        try:
            while True:
                message = self.log_queue.get_nowait()
                self.log_text.insert(tk.END, f"{message}\n")
                self.log_text.see(tk.END)
        except queue.Empty:
            pass
        
        # Her 100ms'de bir kontrol et
        self.root.after(100, self.update_log)

    def browse_folder(self):
        """Kullanƒ±cƒ±nƒ±n klas√∂r se√ßmesini saƒülar"""
        folder_selected = filedialog.askdirectory()
        if folder_selected:
            self.project_path_var.set(folder_selected)
            self.current_directory = folder_selected
            
            # Proje adƒ±nƒ± otomatik √∂ner
            folder_name = os.path.basename(folder_selected)
            if not self.project_name.get().strip():
                self.project_name.set(folder_name)
            
            self.log_message(f"üìÅ Proje klas√∂r√º se√ßildi: {folder_selected}")
            
            # Repository durumunu kontrol et
            self.check_repository_status()
            
            # Git durumunu yeni klas√∂r i√ßin g√ºncelle
            self.check_git_status()
            
            # UI'ƒ± repository durumuna g√∂re g√ºncelle
            self.refresh_ui_after_folder_change()
            
            # README adƒ±mƒ±ndaki repository durumunu g√ºncelle (eƒüer o adƒ±mdaysak)
            if hasattr(self, 'update_readme_repo_status'):
                try:
                    self.update_readme_repo_status()
                except Exception as e:
                    # Hata durumunda sadece log'a yaz, uygulamayƒ± durdurma
                    self.log_message(f"‚ö†Ô∏è README repository durumu g√ºncellenirken hata: {e}")
            
            # Klas√∂rdeki dosyalarƒ± listele
            self.list_folder_contents()

    def check_repository_status(self):
        """Repository durumunu kontrol et ve log'a yaz"""
        try:
            if not self.current_directory:
                return
                
            git_dir = os.path.join(self.current_directory, ".git")
            if os.path.exists(git_dir):
                # Git repository mevcut
                self.log_message("üîç Repository durumu kontrol ediliyor...")
                
                # Git status kontrol et
                try:
                    result = subprocess.run("git status --porcelain", shell=True, 
                                          capture_output=True, text=True, cwd=self.current_directory, timeout=10)
                    if result.returncode == 0:
                        if result.stdout.strip():
                            self.log_message("üìù Repository'de deƒüi≈üiklikler mevcut")
                        else:
                            self.log_message("‚úÖ Repository temiz (deƒüi≈üiklik yok)")
                    else:
                        self.log_message("‚ö†Ô∏è Git status kontrol edilemedi")
                except Exception as e:
                    self.log_message(f"‚ö†Ô∏è Git status hatasƒ±: {e}")
                
                # Remote origin kontrol et
                try:
                    result = subprocess.run("git remote -v", shell=True, 
                                          capture_output=True, text=True, cwd=self.current_directory, timeout=10)
                    if result.returncode == 0 and result.stdout.strip():
                        self.log_message("üîó Remote origin baƒülƒ±")
                    else:
                        self.log_message("‚ö†Ô∏è Remote origin bulunamadƒ±")
                except Exception as e:
                    self.log_message(f"‚ö†Ô∏è Remote kontrol hatasƒ±: {e}")
                
                # Branch bilgisi
                try:
                    result = subprocess.run("git branch --show-current", shell=True, 
                                          capture_output=True, text=True, cwd=self.current_directory, timeout=10)
                    if result.returncode == 0:
                        current_branch = result.stdout.strip()
                        self.log_message(f"üåø Aktif branch: {current_branch}")
                    else:
                        self.log_message("‚ö†Ô∏è Aktif branch bilgisi alƒ±namadƒ±")
                except Exception as e:
                    self.log_message(f"‚ö†Ô∏è Branch kontrol hatasƒ±: {e}")
                    
            else:
                # Git repository yok
                self.log_message("‚ùå Bu klas√∂rde Git repository bulunamadƒ±")
                self.log_message("üí° Repository baƒülamak i√ßin 'Repository Baƒüla' butonunu kullanƒ±n")
                
        except Exception as e:
            self.log_message(f"‚ö†Ô∏è Repository durumu kontrol edilirken hata: {e}")

    def refresh_ui_after_repo_check(self):
        """Repository kontrol√ºnden sonra UI'ƒ± g√ºncelle"""
        try:
            if not self.current_directory:
                return
                
            git_dir = os.path.join(self.current_directory, ".git")
            repo_exists = os.path.exists(git_dir)
            
            if repo_exists:
                # Repository bilgilerini al (sessizce)
                try:
                    # Aktif branch
                    result = subprocess.run("git branch --show-current", shell=True, 
                                          capture_output=True, text=True, cwd=self.current_directory, timeout=10)
                    current_branch = result.stdout.strip() if result.returncode == 0 else "main"
                    
                    # Remote origin
                    result = subprocess.run("git remote get-url origin", shell=True, 
                                          capture_output=True, text=True, cwd=self.current_directory, timeout=10)
                    remote_url = result.stdout.strip() if result.returncode == 0 else "Bilinmiyor"
                    
                    # Commit sayƒ±sƒ±
                    result = subprocess.run("git rev-list --count HEAD", shell=True, 
                                          capture_output=True, text=True, cwd=self.current_directory, timeout=10)
                    commit_count = result.stdout.strip() if result.returncode == 0 else "0"
                    
                except Exception as e:
                    pass  # Sessizce devam et
                
            else:
                self.log_message("üí° Repository bulunamadƒ± - README adƒ±mƒ±nda 'Repository Baƒüla' butonunu kullanƒ±n")
                
        except Exception as e:
            self.log_message(f"‚ö†Ô∏è UI g√ºncellenirken hata: {e}")

    def refresh_ui_after_folder_change(self):
        """Klas√∂r deƒüi≈üikliƒüi sonrasƒ± UI'ƒ± g√ºncelle"""
        try:
            self.log_message("üîÑ Klas√∂r deƒüi≈üikliƒüi - UI g√ºncelleniyor...")
            
            # Repository durumunu kontrol et
            git_dir = os.path.join(self.current_directory, ".git")
            repo_exists = os.path.exists(git_dir) and os.path.isdir(git_dir)
            
            # Repository saƒülƒ±ƒüƒ±nƒ± kontrol et
            if repo_exists:
                try:
                    result = subprocess.run("git status", shell=True, capture_output=True, 
                                          text=True, cwd=self.current_directory, timeout=5)
                    if result.returncode != 0:
                        repo_exists = False
                        self.log_message("‚ö†Ô∏è Repository bozuk - UI g√ºncelleniyor")
                except:
                    repo_exists = False
                    self.log_message("‚ö†Ô∏è Repository eri≈üilemez - UI g√ºncelleniyor")
            
            # T√ºm UI bile≈üenlerini g√ºncelle
            if repo_exists:
                self.log_message("‚úÖ Repository mevcut - T√ºm UI bile≈üenleri g√ºncelleniyor")
                
                # Yayƒ±n butonunu aktif hale getir
                if hasattr(self, 'main_button'):
                    try:
                        if self.main_button.winfo_exists():
                            self.main_button.config(state="normal")
                    except tk.TclError:
                        pass
                
                # README durumunu g√ºncelle
                self.update_readme_repo_status()
                
            else:
                self.log_message("‚ùå Repository bulunamadƒ± - UI devre dƒ±≈üƒ± bƒ±rakƒ±lƒ±yor")
                
                # Yayƒ±n butonunu devre dƒ±≈üƒ± bƒ±rak
                if hasattr(self, 'main_button'):
                    try:
                        if self.main_button.winfo_exists():
                            self.main_button.config(state="disabled")
                    except tk.TclError:
                        pass
                
                # README durumunu g√ºncelle
                self.update_readme_repo_status()
            
            self.log_message("‚úÖ UI g√ºncelleme tamamlandƒ±")
            
        except Exception as e:
            self.log_message(f"‚ö†Ô∏è UI g√ºncelleme hatasƒ±: {e}")

    def validate_inputs(self):
        """Kullanƒ±cƒ± giri≈ülerini doƒürula"""
        project_name = self.project_name.get().strip()
        github_username = self.github_username.get().strip()
        
        if not project_name:
            messagebox.showerror("Hata", "Proje adƒ± bo≈ü olamaz!")
            return False
        
        if not github_username:
            messagebox.showerror("Hata", "GitHub kullanƒ±cƒ± adƒ± bo≈ü olamaz!")
            return False
        
        # Ge√ßersiz karakterleri kontrol et
        invalid_chars = [' ', '/', '\\', ':', '*', '?', '"', '<', '>', '|', '@', '{', '}']
        if any(char in project_name for char in invalid_chars):
            messagebox.showerror("Hata", f"Proje adƒ±nda ge√ßersiz karakterler var!\nGe√ßersiz: {' '.join(invalid_chars)}")
            return False
        
        if any(char in github_username for char in invalid_chars):
            messagebox.showerror("Hata", f"GitHub kullanƒ±cƒ± adƒ±nda ge√ßersiz karakterler var!\nGe√ßersiz: {' '.join(invalid_chars)}")
            return False
        
        if not os.path.exists(self.current_directory):
            messagebox.showerror("Hata", "Proje klas√∂r√º bulunamadƒ±!\nL√ºtfen ge√ßerli bir klas√∂r se√ßin.")
            return False
        
        return True

    def connect_repository(self):
        """Repository baƒülama - bo≈ü repo olu≈ütur ve first commit at"""
        if not self.validate_inputs():
            return
            
        # Onay dialog'u g√∂ster
        result = messagebox.askyesno(
            "Repository Baƒüla",
            f"üîó GitHub'da '{self.project_name.get()}' repository'si olu≈üturulacak ve baƒülanacak.\n\n"
            f"üìÅ Klas√∂r: {self.current_directory}\n"
            f"üë§ Kullanƒ±cƒ±: {self.github_username.get()}\n"
            f"üìù ƒ∞lk commit: {self.commit_message.get()}\n\n"
            "Devam etmek istiyor musunuz?"
        )
        
        if result:
            self.log_message("üîó Repository baƒülama i≈ülemi ba≈ülƒ±yor...")
            
            # README adƒ±mƒ±ndaki butonu devre dƒ±≈üƒ± bƒ±rak (eƒüer varsa)
            if hasattr(self, 'connect_button_readme'):
                try:
                    if self.connect_button_readme.winfo_exists():
                        self.connect_button_readme.config(state='disabled')
                except tk.TclError:
                    pass  # Widget referans hatasƒ± durumunda sessizce devam et
            
            # Yayƒ±n butonunu devre dƒ±≈üƒ± bƒ±rak (eƒüer varsa)
            if hasattr(self, 'main_button'):
                try:
                    if self.main_button.winfo_exists():
                        self.main_button.config(state='disabled')
                except tk.TclError:
                    pass  # Widget referans hatasƒ± durumunda sessizce devam et
            
            self.progress.start()
            
            # Repository baƒülama i≈ülemini thread'de √ßalƒ±≈ütƒ±r
            threading.Thread(target=self.connect_repository_worker, daemon=True).start()
    
    def connect_repository_worker(self):
        """Repository baƒülama i≈ülemi - arka planda √ßalƒ±≈üƒ±r"""
        try:
            original_dir = os.getcwd()
            os.chdir(self.current_directory)
            
            # 1. Git init
            self.log_message("üîß Git repository ba≈ülatƒ±lƒ±yor...")
            result = subprocess.run("git init", shell=True, capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                raise Exception(f"Git init hatasƒ±: {result.stderr}")
            self.log_message("‚úÖ Git repository ba≈ülatƒ±ldƒ±")
            
            # 2. README.md olu≈ütur (eƒüer yoksa)
            if self.readme_var.get() == "create":
                readme_path = os.path.join(self.current_directory, "README.md")
                if not os.path.exists(readme_path):
                    self.log_message("üìù README.md olu≈üturuluyor...")
                    readme_content = f"# {self.project_name.get()}\n\nBu proje GitAuto ile otomatik olarak olu≈üturuldu.\n"
                    with open(readme_path, "w", encoding="utf-8") as f:
                        f.write(readme_content)
                    self.log_message("‚úÖ README.md olu≈üturuldu")
            
            # 3. Sadece README.md ve .gitignore ekle (t√ºm dosyalar deƒüil)
            self.log_message("üìÅ Sadece README.md ve .gitignore ekleniyor...")
            
            # .gitignore'ƒ± g√ºncelle
            self.update_gitignore_for_large_files()
            
            # √ñnce .gitignore'ƒ± ekle
            subprocess.run("git add .gitignore", shell=True, capture_output=True, text=True, timeout=10)
            
            # Sadece README.md ekle (eƒüer varsa)
            readme_path = os.path.join(self.current_directory, "README.md")
            if os.path.exists(readme_path):
                result = subprocess.run("git add README.md", shell=True, capture_output=True, text=True, timeout=10)
                if result.returncode != 0:
                    raise Exception(f"README.md ekleme hatasƒ±: {result.stderr}")
                self.log_message("‚úÖ README.md eklendi")
            else:
                self.log_message("‚ö†Ô∏è README.md bulunamadƒ±")
                result = subprocess.run("git add .", shell=True, capture_output=True, text=True, timeout=10)
                if result.returncode != 0:
                    raise Exception(f"Git add hatasƒ±: {result.stderr}")
                self.log_message("‚úÖ Dosyalar eklendi")
            
            self.log_message("‚úÖ Sadece gerekli dosyalar eklendi (t√ºm dosyalar deƒüil)")
            
            # 4. Git commit (konfig√ºrasyon kontrol√º ile)
            commit_msg = self.commit_message.get().strip() or "first commit"
            self.log_message(f"üíæ ƒ∞lk commit yapƒ±lƒ±yor: {commit_msg}")
            
            # Git konfig√ºrasyonunu kontrol et ve ayarla
            self.log_message("‚öôÔ∏è Git konfig√ºrasyonu kontrol ediliyor...")
            
            # User name kontrol et
            user_result = subprocess.run("git config user.name", shell=True, capture_output=True, text=True, timeout=5)
            if user_result.returncode != 0 or not user_result.stdout.strip():
                self.log_message("üë§ Git user.name ayarlanƒ±yor...")
                subprocess.run(f'git config user.name "{self.github_username.get()}"', shell=True, capture_output=True, text=True, timeout=5)
            
            # User email kontrol et
            email_result = subprocess.run("git config user.email", shell=True, capture_output=True, text=True, timeout=5)
            if email_result.returncode != 0 or not email_result.stdout.strip():
                self.log_message("üìß Git user.email ayarlanƒ±yor...")
                subprocess.run(f'git config user.email "{self.github_username.get()}@users.noreply.github.com"', shell=True, capture_output=True, text=True, timeout=5)
            
            # Commit yap
            result = subprocess.run(f'git commit -m "{commit_msg}"', shell=True, capture_output=True, text=True, timeout=15)
            if result.returncode != 0:
                error_msg = result.stderr.strip() if result.stderr else "Bilinmeyen commit hatasƒ±"
                self.log_message(f"‚ö†Ô∏è Commit hatasƒ±: {error_msg}")
                
                # Alternatif commit y√∂ntemi dene
                self.log_message("üîÑ Alternatif commit y√∂ntemi deneniyor...")
                result = subprocess.run(f'git commit -m "{commit_msg}" --allow-empty', shell=True, capture_output=True, text=True, timeout=15)
                if result.returncode != 0:
                    raise Exception(f"Git commit hatasƒ±: {result.stderr}")
            
            self.log_message("‚úÖ ƒ∞lk commit tamamlandƒ±")
            
            # 5. Branch ayarla
            target_branch = self.selected_branch.get() or "main"
            self.log_message(f"üåø Branch '{target_branch}' ayarlanƒ±yor...")
            result = subprocess.run(f"git branch -M {target_branch}", shell=True, capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                self.log_message(f"‚ö†Ô∏è Branch ayarlama uyarƒ±sƒ±: {result.stderr}")
            else:
                self.log_message(f"‚úÖ Branch '{target_branch}' ayarlandƒ±")
            
            # 6. Remote ekle
            repo_url = f"https://github.com/{self.github_username.get()}/{self.project_name.get()}.git"
            self.log_message(f"üîó Remote repository baƒülanƒ±yor: {repo_url}")
            result = subprocess.run(f'git remote add origin "{repo_url}"', shell=True, capture_output=True, text=True, timeout=10)
            if result.returncode != 0 and "already exists" not in result.stderr:
                raise Exception(f"Remote add hatasƒ±: {result.stderr}")
            self.log_message("‚úÖ Remote repository baƒülandƒ±")
            
            # 7. Push
            self.log_message(f"üöÄ GitHub'a yayƒ±nlanƒ±yor...")
            self.log_message("‚è≥ Bu i≈ülem b√ºy√ºk projelerde biraz zaman alabilir...")
            result = subprocess.run(f"git push -u origin {target_branch}", shell=True, capture_output=True, text=True, timeout=120)
            if result.returncode != 0:
                raise Exception(f"Push hatasƒ±: {result.stderr}")
            self.log_message("‚úÖ Repository GitHub'a yayƒ±nlandƒ±!")
            
            os.chdir(original_dir)
            
            # Ba≈üarƒ± mesajƒ±
            self.root.after(0, lambda: messagebox.showinfo(
                "Ba≈üarƒ±lƒ±! üéâ",
                f"üîó Repository ba≈üarƒ±yla baƒülandƒ±!\n\n"
                f"üìç URL: https://github.com/{self.github_username.get()}/{self.project_name.get()}\n"
                f"üåø Branch: {target_branch}\n\n"
                "Artƒ±k branch i≈ülemleri yapabilir ve yayƒ±nlama yapabilirsiniz!"
            ))
            
            # Yayƒ±n butonunu aktif hale getir
            self.root.after(0, lambda: self.main_button.config(state="normal"))
             
            # README adƒ±mƒ±ndaki repository durumunu g√ºncelle
            self.root.after(0, self.update_readme_repo_status)
            
            # Branch listesini g√ºncelle
            self.root.after(100, self.refresh_branches)
            
        except Exception as e:
            os.chdir(original_dir)
            error_msg = str(e)  # Hata mesajƒ±nƒ± string olarak sakla
            self.log_message(f"‚ùå Repository baƒülama hatasƒ±: {error_msg}")
            self.root.after(0, lambda: messagebox.showerror("Hata", f"Repository baƒülama hatasƒ±:\n{error_msg}"))
        
        finally:
            self.root.after(0, self.repository_connect_finished)
    
    def repository_connect_finished(self):
        """Repository baƒülama i≈ülemi tamamlandƒ±"""
        # README adƒ±mƒ±ndaki butonu aktif hale getir (eƒüer varsa)
        if hasattr(self, 'connect_button_readme'):
            try:
                if self.connect_button_readme.winfo_exists():
                    self.connect_button_readme.config(state='normal')
            except tk.TclError:
                pass  # Widget referans hatasƒ± durumunda sessizce devam et
        
        # Repository baƒülandƒ±ktan sonra yayƒ±n butonunu aktif hale getir
        if hasattr(self, 'main_button'):
            try:
                if self.main_button.winfo_exists():
                    self.main_button.config(state='normal')
            except tk.TclError:
                pass  # Widget referans hatasƒ± durumunda sessizce devam et
        
        self.progress.stop()
        self.check_git_status()

    def refresh_branches(self):
        """Ger√ßek branch'leri listele ve combo box'ƒ± g√ºncelle"""
        try:
            # branch_combo hen√ºz olu≈üturulmamƒ±≈üsa bekle
            if not hasattr(self, 'branch_combo'):
                return
                
            if not os.path.exists(os.path.join(self.current_directory, ".git")):
                self.branch_combo['values'] = ["main", "master", "develop"]
                self.log_message("‚ÑπÔ∏è Git repository hen√ºz ba≈ülatƒ±lmamƒ±≈ü - varsayƒ±lan branch'ler g√∂steriliyor")
                return
            
            original_dir = os.getcwd()
            os.chdir(self.current_directory)
            
            # Local branch'leri al
            result = subprocess.run("git branch", shell=True, capture_output=True, text=True, timeout=10)
            local_branches = []
            
            if result.returncode == 0 and result.stdout:
                for line in result.stdout.strip().split('\n'):
                    if line.strip():
                        branch = line.strip().replace('*', '').strip()
                        if branch and not branch.startswith('('):
                            local_branches.append(branch)
            
            # Remote branch'leri al
            result = subprocess.run("git branch -r", shell=True, capture_output=True, text=True, timeout=10)
            remote_branches = []
            
            if result.returncode == 0 and result.stdout:
                for line in result.stdout.strip().split('\n'):
                    if line.strip() and 'origin/' in line:
                        branch = line.strip().replace('origin/', '').strip()
                        if branch and branch != 'HEAD' and not branch.startswith('('):
                            remote_branches.append(branch)
            
            # T√ºm branch'leri birle≈ütir ve tekrarlarƒ± kaldƒ±r
            all_branches = list(set(local_branches + remote_branches))
            
            # Varsayƒ±lan branch'leri ekle
            default_branches = ["main", "master", "develop"]
            for branch in default_branches:
                if branch not in all_branches:
                    all_branches.append(branch)
            
            # Sƒ±rala
            all_branches.sort()
            
            # Combo box'ƒ± g√ºncelle
            self.branch_combo['values'] = all_branches
            
            # Mevcut branch'ƒ± se√ß
            current_result = subprocess.run("git branch --show-current", shell=True, capture_output=True, text=True, timeout=5)
            if current_result.returncode == 0 and current_result.stdout.strip():
                current_branch = current_result.stdout.strip()
                if current_branch in all_branches:
                    self.selected_branch.set(current_branch)
                    self.log_message(f"üåø Aktif branch: {current_branch}")
            
            self.log_message(f"üîÑ Branch listesi g√ºncellendi: {len(all_branches)} branch bulundu")
            
            os.chdir(original_dir)
            
        except Exception as e:
            self.log_message(f"‚ö†Ô∏è Branch listesi g√ºncellenirken hata: {e}")
            self.branch_combo['values'] = ["main", "master", "develop"]

    def clean_repository(self):
        """Repository'yi temizle - gereksiz dosyalarƒ± kaldƒ±r"""
        try:
            if not os.path.exists(os.path.join(self.current_directory, ".git")):
                messagebox.showerror("Hata", "Git repository bulunamadƒ±!")
                return
            
            # Onay al
            result = messagebox.askyesno(
                "Repository Temizle",
                "üßπ Repository temizlenecek:\n\n"
                "‚Ä¢ Gereksiz dosyalar kaldƒ±rƒ±lacak\n"
                "‚Ä¢ .gitignore g√ºncellenecek\n"
                "‚Ä¢ Git cache temizlenecek\n\n"
                "Devam etmek istiyor musunuz?"
            )
            
            if result:
                self.log_message("üßπ Repository temizleme ba≈ülatƒ±lƒ±yor...")
                
                original_dir = os.getcwd()
                os.chdir(self.current_directory)
                
                # Git cache temizle
                self.log_message("üóëÔ∏è Git cache temizleniyor...")
                subprocess.run("git gc", shell=True, capture_output=True, text=True, timeout=30)
                
                # Git ignore g√ºncelle
                gitignore_path = os.path.join(self.current_directory, ".gitignore")
                if not os.path.exists(gitignore_path):
                    self.log_message("üìù .gitignore olu≈üturuluyor...")
                    with open(gitignore_path, "w", encoding="utf-8") as f:
                        f.write("# GitAuto tarafƒ±ndan olu≈üturuldu\n")
                        f.write("# Dependencies\n")
                        f.write("node_modules/\n")
                        f.write("npm-debug.log*\n")
                        f.write("yarn-debug.log*\n")
                        f.write("yarn-error.log*\n")
                        f.write("package-lock.json\n")
                        f.write("yarn.lock\n")
                        f.write("\n# Build outputs\n")
                        f.write("build/\n")
                        f.write("dist/\n")
                        f.write("out/\n")
                        f.write("target/\n")
                        f.write("*.exe\n")
                        f.write("*.msi\n")
                        f.write("*.dmg\n")
                        f.write("*.app\n")
                        f.write("\n# Large files\n")
                        f.write("*.zip\n")
                        f.write("*.tar.gz\n")
                        f.write("*.rar\n")
                        f.write("*.7z\n")
                        f.write("*.iso\n")
                        f.write("*.dmg\n")
                        f.write("*.pkg\n")
                        f.write("\n# Python\n")
                        f.write("__pycache__/\n")
                        f.write("*.pyc\n")
                        f.write("*.pyo\n")
                        f.write("*.pyd\n")
                        f.write("*.so\n")
                        f.write("\n# IDE\n")
                        f.write(".vscode/\n")
                        f.write(".idea/\n")
                        f.write("*.swp\n")
                        f.write("*.swo\n")
                        f.write("\n# Logs\n")
                        f.write("*.log\n")
                        f.write("logs/\n")
                        f.write("*.pid\n")
                        f.write("*.seed\n")
                        f.write("\n# OS\n")
                        f.write(".DS_Store\n")
                        f.write("Thumbs.db\n")
                        f.write("desktop.ini\n")
                        f.write("\n# Cache\n")
                        f.write(".cache/\n")
                        f.write("*.cache\n")
                        f.write("tmp/\n")
                        f.write("temp/\n")
                
                # B√ºy√ºk dosyalarƒ± tespit et ve filtrele
                self.log_message("üîç B√ºy√ºk dosyalar tespit ediliyor...")
                self.detect_and_filter_large_files()
                
                # Gereksiz dosyalarƒ± kaldƒ±r
                self.log_message("üìÅ Gereksiz dosyalar kaldƒ±rƒ±lƒ±yor...")
                
                # √ñnce b√ºy√ºk dosyalarƒ± Git cache'inden kaldƒ±r
                self.log_message("üóëÔ∏è B√ºy√ºk dosyalar Git cache'inden kaldƒ±rƒ±lƒ±yor...")
                self.remove_large_files_from_git()
                
                # T√ºm dosyalarƒ± cache'den kaldƒ±r
                subprocess.run("git rm -r --cached .", shell=True, capture_output=True, text=True, timeout=30)
                
                # .gitignore'ƒ± g√ºncelle ve tekrar ekle
                subprocess.run("git add .gitignore", shell=True, capture_output=True, text=True, timeout=10)
                
                # Temizlenmi≈ü dosyalarƒ± ekle
                subprocess.run("git add .", shell=True, capture_output=True, text=True, timeout=60)
                
                # Commit (konfig√ºrasyon kontrol√º ile)
                self.log_message("üíæ Temizlik commit'i yapƒ±lƒ±yor...")
                
                # Git konfig√ºrasyonunu kontrol et
                user_result = subprocess.run("git config user.name", shell=True, capture_output=True, text=True, timeout=5)
                if user_result.returncode != 0 or not user_result.stdout.strip():
                    subprocess.run('git config user.name "GitAuto"', shell=True, capture_output=True, text=True, timeout=5)
                
                email_result = subprocess.run("git config user.email", shell=True, capture_output=True, text=True, timeout=5)
                if email_result.returncode != 0 or not email_result.stdout.strip():
                    subprocess.run('git config user.email "gitauto@users.noreply.github.com"', shell=True, capture_output=True, text=True, timeout=5)
                
                commit_result = subprocess.run('git commit -m "Repository temizlendi - GitAuto"', 
                             shell=True, capture_output=True, text=True, timeout=30)
                
                if commit_result.returncode != 0:
                    self.log_message("‚ö†Ô∏è Commit hatasƒ±, alternatif y√∂ntem deneniyor...")
                    subprocess.run('git commit -m "Repository temizlendi - GitAuto" --allow-empty', 
                                 shell=True, capture_output=True, text=True, timeout=30)
                
                os.chdir(original_dir)
                
                self.log_message("‚úÖ Repository ba≈üarƒ±yla temizlendi!")
                messagebox.showinfo("Ba≈üarƒ±lƒ±! üéâ", "Repository temizlendi!\n\nArtƒ±k daha hƒ±zlƒ± √ßalƒ±≈üacak.")
                
        except Exception as e:
            self.log_message(f"‚ùå Repository temizleme hatasƒ±: {e}")
            messagebox.showerror("Hata", f"Repository temizleme hatasƒ±:\n{e}")

    def detect_and_filter_large_files(self):
        """B√ºy√ºk dosyalarƒ± tespit et ve .gitignore'a ekle"""
        try:
            self.log_message("üîç B√ºy√ºk dosyalar taranƒ±yor...")
            gitignore_path = os.path.join(self.current_directory, ".gitignore")
            
            # .gitignore yoksa olu≈ütur
            if not os.path.exists(gitignore_path):
                with open(gitignore_path, "w", encoding="utf-8") as f:
                    f.write("# GitAuto tarafƒ±ndan olu≈üturuldu\n")
            
            # √ñnce node_modules klas√∂r√ºn√º tamamen yoksay
            node_modules_path = os.path.join(self.current_directory, "node_modules")
            if os.path.exists(node_modules_path):
                self.log_message("üö´ node_modules klas√∂r√º tespit edildi - tamamen yoksayƒ±lƒ±yor")
                
                # .gitignore'a node_modules ekle
                with open(gitignore_path, "a", encoding="utf-8") as f:
                    f.write("\n# Node.js dependencies - COMPLETELY IGNORED\n")
                    f.write("node_modules/\n")
                    f.write("node_modules/**\n")
                    f.write("**/node_modules/\n")
                    f.write("**/node_modules/**\n")
                
                # Git cache'den de kaldƒ±r
                try:
                    subprocess.run("git rm -r --cached node_modules", shell=True, 
                                 capture_output=True, text=True, cwd=self.current_directory, timeout=30)
                    self.log_message("‚úÖ node_modules Git cache'den kaldƒ±rƒ±ldƒ±")
                except:
                    pass
            
            large_file_threshold = 50 * 1024 * 1024  # 50MB
            large_files = []
            
            # Proje klas√∂r√ºndeki t√ºm dosyalarƒ± tara
            for root, dirs, files in os.walk(self.current_directory):
                # .git ve node_modules klas√∂rlerini atla
                if '.git' in dirs:
                    dirs.remove('.git')
                if 'node_modules' in dirs:
                    dirs.remove('node_modules')
                
                for file in files:
                    file_path = os.path.join(root, file)
                    try:
                        file_size = os.path.getsize(file_path)
                        if file_size > large_file_threshold:
                            # Dosya yolƒ±nƒ± proje klas√∂r√ºne g√∂re relatif yap
                            rel_path = os.path.relpath(file_path, self.current_directory)
                            large_files.append((rel_path, file_size))
                    except (OSError, PermissionError):
                        continue
            
            if large_files:
                self.log_message(f"üö® {len(large_files)} b√ºy√ºk dosya tespit edildi:")
                for file_path, file_size in sorted(large_files, key=lambda x: x[1], reverse=True):
                    size_mb = file_size / (1024 * 1024)
                    self.log_message(f"  üìÅ {file_path} ({size_mb:.1f} MB)")
                
                # .gitignore dosyasƒ±nƒ± g√ºncelle
                if os.path.exists(gitignore_path):
                    with open(gitignore_path, "a", encoding="utf-8") as f:
                        f.write("\n# Large files detected by GitAuto\n")
                        for file_path, _ in large_files:
                            # Dosya yolƒ±nƒ± .gitignore formatƒ±na √ßevir
                            if os.path.sep == '\\':  # Windows
                                file_path = file_path.replace('\\', '/')
                            f.write(f"{file_path}\n")
                    
                    self.log_message("‚úÖ .gitignore dosyasƒ± b√ºy√ºk dosyalarla g√ºncellendi")
                else:
                    self.log_message("‚ö†Ô∏è .gitignore dosyasƒ± bulunamadƒ±, b√ºy√ºk dosyalar eklenebilir")
            else:
                self.log_message("‚úÖ B√ºy√ºk dosya tespit edilmedi")
                
        except Exception as e:
            self.log_message(f"‚ö†Ô∏è B√ºy√ºk dosya tespiti sƒ±rasƒ±nda hata: {e}")

    def remove_large_files_from_git(self):
        """Git cache'inden b√ºy√ºk dosyalarƒ± kaldƒ±r"""
        try:
            # Git cache'deki b√ºy√ºk dosyalarƒ± bul
            self.log_message("üîç Git cache'deki b√ºy√ºk dosyalar aranƒ±yor...")
            
            # Git ls-files ile cache'deki dosyalarƒ± listele
            result = subprocess.run("git ls-files", shell=True, capture_output=True, 
                                  text=True, cwd=self.current_directory, timeout=30)
            
            if result.returncode != 0:
                self.log_message("‚ö†Ô∏è Git cache listesi alƒ±namadƒ±")
                return
            
            large_files_in_git = []
            large_file_threshold = 50 * 1024 * 1024  # 50MB
            
            for line in result.stdout.strip().split('\n'):
                if not line.strip():
                    continue
                
                file_path = os.path.join(self.current_directory, line)
                if os.path.exists(file_path):
                    try:
                        file_size = os.path.getsize(file_path)
                        if file_size > large_file_threshold:
                            large_files_in_git.append((line, file_size))
                    except (OSError, PermissionError):
                        continue
            
            if large_files_in_git:
                self.log_message(f"üö® Git cache'de {len(large_files_in_git)} b√ºy√ºk dosya bulundu:")
                
                for file_path, file_size in sorted(large_files_in_git, key=lambda x: x[1], reverse=True):
                    size_mb = file_size / (1024 * 1024)
                    self.log_message(f"  üìÅ {file_path} ({size_mb:.1f} MB)")
                    
                    # B√ºy√ºk dosyayƒ± Git cache'inden kaldƒ±r
                    try:
                        subprocess.run(f'git rm --cached "{file_path}"', shell=True, 
                                     capture_output=True, text=True, cwd=self.current_directory, timeout=10)
                        self.log_message(f"  ‚úÖ {file_path} Git cache'den kaldƒ±rƒ±ldƒ±")
                    except Exception as e:
                        self.log_message(f"  ‚ùå {file_path} kaldƒ±rƒ±lamadƒ±: {e}")
                
                # .gitignore'a ekle
                gitignore_path = os.path.join(self.current_directory, ".gitignore")
                if os.path.exists(gitignore_path):
                    with open(gitignore_path, "a", encoding="utf-8") as f:
                        f.write("\n# Large files removed from Git cache\n")
                        for file_path, _ in large_files_in_git:
                            # Dosya yolƒ±nƒ± .gitignore formatƒ±na √ßevir
                            if os.path.sep == '\\':  # Windows
                                file_path = file_path.replace('\\', '/')
                            f.write(f"{file_path}\n")
                    
                    self.log_message("‚úÖ .gitignore dosyasƒ± g√ºncellendi")
                
                # √ñzel olarak node_modules klas√∂r√ºn√º kaldƒ±r
                if any('node_modules' in file_path for file_path, _ in large_files_in_git):
                    self.log_message("üö´ node_modules klas√∂r√º Git cache'den kaldƒ±rƒ±lƒ±yor...")
                    try:
                        # √ñnce t√ºm node_modules dosyalarƒ±nƒ± tek tek kaldƒ±r
                        subprocess.run("git rm -r --cached node_modules", shell=True, 
                                     capture_output=True, text=True, cwd=self.current_directory, timeout=30)
                        
                        # Git history'den de temizle (daha agresif)
                        subprocess.run("git filter-branch --force --index-filter 'git rm -r --cached --ignore-unmatch node_modules' --prune-empty --tag-name-filter cat -- --all", 
                                     shell=True, capture_output=True, text=True, cwd=self.current_directory, timeout=60)
                        
                        # Git garbage collection yap
                        subprocess.run("git gc --prune=now", shell=True, 
                                     capture_output=True, text=True, cwd=self.current_directory, timeout=30)
                        
                        self.log_message("‚úÖ node_modules klas√∂r√º Git history'den tamamen temizlendi")
                    except Exception as e:
                        self.log_message(f"‚ö†Ô∏è node_modules temizlenemedi: {e}")
                        
                        # Alternatif y√∂ntem: Force clean
                        self.log_message("üîÑ Alternatif temizlik y√∂ntemi deneniyor...")
                        try:
                            subprocess.run("git clean -fdx", shell=True, 
                                         capture_output=True, text=True, cwd=self.current_directory, timeout=30)
                            subprocess.run("git reset --hard HEAD", shell=True, 
                                         capture_output=True, text=True, cwd=self.current_directory, timeout=30)
                            self.log_message("‚úÖ Alternatif temizlik tamamlandƒ±")
                        except Exception as e2:
                            self.log_message(f"‚ùå Alternatif temizlik de ba≈üarƒ±sƒ±z: {e2}")
                            
                            # Son √ßare: Repository'yi tamamen yeniden ba≈ülat
                            self.log_message("üö® Son √ßare: Repository tamamen yeniden ba≈ülatƒ±lƒ±yor...")
                            try:
                                # .git klas√∂r√ºn√º yedekle
                                git_backup = os.path.join(self.current_directory, ".git_backup")
                                if os.path.exists(os.path.join(self.current_directory, ".git")):
                                    import shutil
                                    shutil.move(os.path.join(self.current_directory, ".git"), git_backup)
                                    self.log_message("‚úÖ .git klas√∂r√º yedeklendi")
                                
                                # Yeni repository ba≈ülat
                                subprocess.run("git init", shell=True, 
                                             capture_output=True, text=True, cwd=self.current_directory, timeout=10)
                                
                                # .gitignore'ƒ± g√ºncelle
                                self.update_gitignore_for_large_files()
                                
                                self.log_message("‚úÖ Repository yeniden ba≈ülatƒ±ldƒ±")
                                self.log_message("üí° Artƒ±k b√ºy√ºk dosyalar olmadan commit yapabilirsiniz")
                                
                            except Exception as e3:
                                self.log_message(f"‚ùå Repository yeniden ba≈ülatƒ±lamadƒ±: {e3}")
                                # Yedekten geri y√ºkle
                                if os.path.exists(git_backup):
                                    import shutil
                                    shutil.move(git_backup, os.path.join(self.current_directory, ".git"))
                                    self.log_message("‚úÖ .git klas√∂r√º yedekten geri y√ºklendi")
            else:
                self.log_message("‚úÖ Git cache'de b√ºy√ºk dosya bulunamadƒ±")
                
        except Exception as e:
            self.log_message(f"‚ö†Ô∏è Git cache temizliƒüi sƒ±rasƒ±nda hata: {e}")

    def update_gitignore_for_large_files(self):
        """B√ºy√ºk dosyalar i√ßin kapsamlƒ± .gitignore olu≈ütur"""
        try:
            gitignore_path = os.path.join(self.current_directory, ".gitignore")
            
            # Kapsamlƒ± .gitignore i√ßeriƒüi
            gitignore_content = """# GitAuto tarafƒ±ndan olu≈üturuldu - B√ºy√ºk dosyalar i√ßin optimize edildi

# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
package-lock.json
yarn.lock
pnpm-lock.yaml

# Build outputs
build/
dist/
out/
target/
*.exe
*.msi
*.dmg
*.app
*.deb
*.rpm
*.pkg

# Large files
*.zip
*.tar.gz
*.rar
*.7z
*.iso
*.dmg
*.pkg
*.bin
*.dat
*.db
*.sqlite
*.sqlite3

# Python
__pycache__/
*.pyc
*.pyo
*.pyd
*.so
*.egg
*.egg-info/
*.whl

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# Logs
*.log
logs/
*.pid
*.seed
*.out

# OS
.DS_Store
Thumbs.db
desktop.ini
*.tmp
*.temp

# Cache
.cache/
*.cache
tmp/
temp/
.tmp/

# Electron specific
node_modules/electron/
node_modules/electron-builder/
node_modules/electron-packager/

# Large media files
*.mp4
*.avi
*.mov
*.wmv
*.flv
*.mkv
*.webm
*.mp3
*.wav
*.flac
*.aac
*.ogg

# Archives
*.zip
*.tar
*.gz
*.bz2
*.xz
*.rar
*.7z
*.lzma
*.lz4

# Database files
*.db
*.sqlite
*.sqlite3
*.mdb
*.accdb

# Virtual environments
venv/
env/
.venv/
.env/
ENV/

# Backup files
*.bak
*.backup
*.old
*.orig
*.save
"""
            
            with open(gitignore_path, "w", encoding="utf-8") as f:
                f.write(gitignore_content)
            
            self.log_message("‚úÖ Kapsamlƒ± .gitignore dosyasƒ± olu≈üturuldu")
            
        except Exception as e:
            self.log_message(f"‚ö†Ô∏è .gitignore olu≈üturulurken hata: {e}")

    def create_new_branch(self):
        """Yeni branch olu≈ütur"""
        branch_name = self.new_branch_var.get().strip()
        if not branch_name:
            messagebox.showerror("Hata", "Branch adƒ± bo≈ü olamaz!")
            return
        
        # Ge√ßersiz karakterleri kontrol et
        invalid_chars = [' ', '/', '\\', ':', '*', '?', '"', '<', '>', '|']
        if any(char in branch_name for char in invalid_chars):
            messagebox.showerror("Hata", f"Branch adƒ±nda ge√ßersiz karakterler var!\nGe√ßersiz karakterler: {' '.join(invalid_chars)}")
            return
        
        def create_branch():
            try:
                self.log_message(f"üå± Yeni branch olu≈üturuluyor: {branch_name}")
                
                if not os.path.exists(os.path.join(self.current_directory, ".git")):
                    self.log_message("‚ùå Git repository hen√ºz ba≈ülatƒ±lmamƒ±≈ü!")
                    self.root.after(0, lambda: messagebox.showerror("Hata", "Git repository hen√ºz ba≈ülatƒ±lmamƒ±≈ü!\n√ñnce 'Repository Baƒüla' butonunu kullanƒ±n."))
                    return
                
                result = subprocess.run(f"git checkout -b {branch_name}", shell=True, 
                                     capture_output=True, text=True, cwd=self.current_directory, timeout=15)
                
                if result.returncode == 0:
                    self.log_message(f"‚úÖ Branch '{branch_name}' ba≈üarƒ±yla olu≈üturuldu!")
                    
                    # Yeni branch'i hedef branch listesine ekle
                    current_values = list(self.branch_combo['values'])
                    if branch_name not in current_values:
                        current_values.append(branch_name)
                        current_values.sort()
                        self.branch_combo['values'] = current_values
                    
                    # Yeni branch'i otomatik se√ß
                    self.selected_branch.set(branch_name)
                    self.log_message(f"üéØ Hedef branch otomatik '{branch_name}' olarak se√ßildi")
                    
                    self.new_branch_var.set("")
                    
                    # Ba≈üarƒ± mesajƒ±
                    self.root.after(0, lambda: messagebox.showinfo(
                        "Ba≈üarƒ±lƒ±! üéâ",
                        f"üå± Branch '{branch_name}' ba≈üarƒ±yla olu≈üturuldu!\n\n"
                        f"‚úÖ Otomatik olarak hedef branch se√ßildi\n"
                        f"üöÄ Artƒ±k yayƒ±nlama yapabilirsiniz"
                    ))
                    
                else:
                    error_msg = result.stderr or "Bilinmeyen hata"
                    if "already exists" in error_msg:
                        self.log_message(f"‚ö†Ô∏è Branch '{branch_name}' zaten mevcut!")
                        self.selected_branch.set(branch_name)
                        self.log_message(f"üéØ Mevcut branch '{branch_name}' hedef olarak se√ßildi")
                    else:
                        self.log_message(f"‚ùå Branch olu≈üturma hatasƒ±: {error_msg}")
                        self.root.after(0, lambda: messagebox.showerror("Hata", f"Branch olu≈üturma hatasƒ±:\n{error_msg}"))
                        
            except Exception as e:
                error_msg = str(e)  # Hata mesajƒ±nƒ± string olarak sakla
                self.log_message(f"‚ùå Branch olu≈üturma hatasƒ±: {error_msg}")
                self.root.after(0, lambda: messagebox.showerror("Hata", f"Branch olu≈üturma hatasƒ±:\n{error_msg}"))
        
        # Thread'de √ßalƒ±≈ütƒ±r
        threading.Thread(target=create_branch, daemon=True).start()

    def list_branches(self):
        """Mevcut branch'leri listele"""
        def list_branches_thread():
            try:
                self.log_message("üìã Mevcut branch'ler listeleniyor...")
                
                if not self.git_repo_exists:
                    self.log_message("‚ÑπÔ∏è  Git repository hen√ºz ba≈ülatƒ±lmamƒ±≈ü")
                    return
                
                result = subprocess.run("git branch", shell=True, capture_output=True, 
                                     text=True, cwd=self.current_directory)
                
                if result.returncode == 0 and result.stdout:
                    self.log_message("üåø Mevcut Branch'ler:")
                    self.log_message("-" * 30)
                    branches = result.stdout.strip().split('\n')
                    for branch in branches:
                        if branch.strip():
                            if branch.startswith('*'):
                                self.log_message(f"  üåü {branch.strip()} (aktif)")
                            else:
                                self.log_message(f"     {branch.strip()}")
                else:
                    self.log_message("‚ÑπÔ∏è  Hen√ºz branch bulunamadƒ±")
                    
            except Exception as e:
                self.log_message(f"‚ùå Branch listeleme hatasƒ±: {e}")
        
        threading.Thread(target=list_branches_thread, daemon=True).start()

    def start_publication(self):
        """Repository yayƒ±nlama i≈ülemini ba≈ülat - T√ºm dosyalar"""
        # Giri≈ü kontrol√º
        if not self.project_name.get().strip():
            messagebox.showerror("Hata", "Proje adƒ± bo≈ü olamaz!")
            return
        
        if not self.github_username.get().strip():
            messagebox.showerror("Hata", "GitHub kullanƒ±cƒ± adƒ± bo≈ü olamaz!")
            return
        
        if not self.git_installed:
            messagebox.showerror("Hata", "Git kurulu deƒüil!\nL√ºtfen √∂nce Git'i y√ºkleyin: https://git-scm.com/downloads")
            return
        
        # Repository varlƒ±ƒüƒ±nƒ± kontrol et
        if not os.path.exists(os.path.join(self.current_directory, ".git")):
            messagebox.showerror("Hata", "Git repository bulunamadƒ±!\n√ñnce README adƒ±mƒ±nda 'Repository Baƒüla' butonunu kullanƒ±n.")
            return
        
        # Onay al - T√ºm dosyalar i√ßin
        project_name = self.project_name.get().strip()
        github_username = self.github_username.get().strip()
        commit_message = self.commit_message.get().strip() or "Final commit - T√ºm dosyalar yayƒ±nlandƒ±"
        target_branch = self.selected_branch.get()
        
        confirm_text = f"""üìã T√ºm Dosyalarƒ± Yayƒ±nlama:

üìÅ Proje: {project_name}
üë§ GitHub: {github_username}
üí¨ Commit: {commit_message}
üåø Branch: {target_branch}

‚ö†Ô∏è Bu i≈ülem t√ºm proje dosyalarƒ±nƒ± yayƒ±nlayacak.
üöÄ B√ºy√ºk dosyalar otomatik olarak filtrelenecek.

‚úÖ Devam edilsin mi?"""
        
        if not messagebox.askyesno("Onay", confirm_text):
            return
        
        # ƒ∞≈ülemi ba≈ülat
        self.main_button.config(state="disabled")
        self.progress.start()
        
        # Thread'de √ßalƒ±≈ütƒ±r - T√ºm dosyalar i√ßin
        threading.Thread(target=self.publish_repository, daemon=True).start()

    def publish_repository(self):
        """T√ºm dosyalarƒ± yayƒ±nla - Son adƒ±m"""
        try:
            project_name = self.project_name.get().strip()
            github_username = self.github_username.get().strip()
            commit_message = self.commit_message.get().strip() or "Final commit - T√ºm dosyalar yayƒ±nlandƒ±"
            target_branch = self.selected_branch.get() or "main"
            
            repo_url = f"https://github.com/{github_username}/{project_name}.git"
            
            self.log_message("üöÄ T√ºm dosyalar yayƒ±nlanƒ±yor...")
            
            # Git repository kontrol√º
            git_dir = os.path.join(self.current_directory, ".git")
            if not os.path.exists(git_dir):
                self.log_message("‚ùå Git repository bulunamadƒ±! √ñnce 'Repository Baƒüla' kullanƒ±n.")
                raise Exception("Git repository bulunamadƒ±! √ñnce 'Repository Baƒüla' kullanƒ±n.")
            
            # Git konfig√ºrasyonunu kontrol et
            self.log_message("‚öôÔ∏è Git konfig√ºrasyonu kontrol ediliyor...")
            
            user_result = subprocess.run("git config user.name", shell=True, capture_output=True, 
                                       text=True, cwd=self.current_directory, timeout=5)
            if user_result.returncode != 0 or not user_result.stdout.strip():
                subprocess.run(f'git config user.name "{github_username}"', shell=True, 
                             capture_output=True, text=True, cwd=self.current_directory, timeout=5)
                self.log_message("üë§ Git user.name ayarlandƒ±")
            
            email_result = subprocess.run("git config user.email", shell=True, capture_output=True, 
                                        text=True, cwd=self.current_directory, timeout=5)
            if email_result.returncode != 0 or not email_result.stdout.strip():
                subprocess.run(f'git config user.email "{github_username}@users.noreply.github.com"', 
                             shell=True, capture_output=True, text=True, cwd=self.current_directory, timeout=5)
                self.log_message("üìß Git user.email ayarlandƒ±")
            
            # B√ºy√ºk dosyalarƒ± kontrol et ve filtrele
            self.log_message("üîç B√ºy√ºk dosyalar kontrol ediliyor...")
            self.detect_and_filter_large_files()
            
            # T√ºm dosyalarƒ± ekle (b√ºy√ºk dosyalar hari√ß)
            self.log_message("üìÅ T√ºm dosyalar ekleniyor...")
            result = subprocess.run("git add .", shell=True, capture_output=True, 
                                 text=True, cwd=self.current_directory, timeout=120)
            
            if result.returncode != 0:
                error_msg = result.stderr.strip() if result.stderr else "Bilinmeyen git add hatasƒ±"
                self.log_message(f"‚ö†Ô∏è Git add hatasƒ±: {error_msg}")
                raise Exception(f"Git add hatasƒ±: {error_msg}")
            
            self.log_message("‚úÖ T√ºm dosyalar eklendi")
            
            # Commit yap
            self.log_message(f"üíæ Final commit atƒ±lƒ±yor: {commit_message}")
            result = subprocess.run(f'git commit -m "{commit_message}"', shell=True, 
                                 capture_output=True, text=True, cwd=self.current_directory, timeout=15)
            
            if result.returncode != 0:
                error_msg = result.stderr.strip() if result.stderr else "Bilinmeyen commit hatasƒ±"
                self.log_message(f"‚ö†Ô∏è Commit hatasƒ±: {error_msg}")
                raise Exception(f"Commit hatasƒ±: {error_msg}")
            
            self.log_message("‚úÖ Final commit ba≈üarƒ±yla atƒ±ldƒ±")
            
            # Push i≈ülemi
            self.log_message(f"üöÄ '{target_branch}' branch'i GitHub'a push ediliyor...")
            result = subprocess.run(f"git push origin {target_branch}", shell=True, capture_output=True, 
                                 text=True, cwd=self.current_directory, timeout=180)
            
            if result.returncode != 0:
                error_msg = result.stderr.strip() if result.stderr else "Bilinmeyen push hatasƒ±"
                self.log_message(f"‚ö†Ô∏è Push hatasƒ±: {error_msg}")
                raise Exception(f"Push hatasƒ±: {error_msg}")
            
            self.log_message("‚úÖ T√ºm dosyalar GitHub'a ba≈üarƒ±yla yayƒ±nlandƒ±!")
            self.log_message("üéâ Proje tamamen yayƒ±nlandƒ±!")
            
            # Ba≈üarƒ± mesajƒ± g√∂ster
            self.root.after(0, lambda: messagebox.showinfo(
                "Ba≈üarƒ±lƒ±! üéâ",
                f"‚úÖ T√ºm dosyalar ba≈üarƒ±yla yayƒ±nlandƒ±!\n\n"
                f"üìç Repository: {repo_url}\n"
                f"üåø Branch: {target_branch}\n"
                f"üí¨ Commit: {commit_message}\n\n"
                "üöÄ Proje tamamen yayƒ±nlandƒ±!"
            ))
            
        except Exception as e:
            self.log_message(f"‚ùå Dosya yayƒ±nlama hatasƒ±: {e}")
            self.root.after(0, lambda: messagebox.showerror("Hata", f"Dosya yayƒ±nlama hatasƒ±:\n{e}"))
        
        finally:
            # UI'ƒ± g√ºncelle
            self.root.after(0, self.publication_finished)



    def publication_finished(self):
        """Yayƒ±nlama i≈ülemi tamamlandƒ±"""
        # Yayƒ±nlama tamamlandƒ±ktan sonra butonlarƒ± g√ºncelle
        if hasattr(self, 'main_button'):
            try:
                if self.main_button.winfo_exists():
                    self.main_button.config(state="normal")
            except tk.TclError:
                pass  # Widget referans hatasƒ± durumunda sessizce devam et
        
        # README adƒ±mƒ±ndaki butonu da g√ºncelle (eƒüer varsa)
        if hasattr(self, 'connect_button_readme'):
            try:
                if self.connect_button_readme.winfo_exists():
                    self.connect_button_readme.config(state="normal")
            except tk.TclError:
                pass  # Widget referans hatasƒ± durumunda sessizce devam et
        
        self.progress.stop()
        self.check_git_status()

    def list_folder_contents(self):
        """Se√ßilen klas√∂rdeki dosyalarƒ± listele"""
        try:
            if not os.path.exists(self.current_directory):
                return
            
            self.log_message(f"üìã Klas√∂r i√ßeriƒüi ({self.current_directory}):")
            self.log_message("-" * 50)
            
            # Dosya ve klas√∂rleri listele
            items = os.listdir(self.current_directory)
            files = []
            folders = []
            
            for item in items:
                item_path = os.path.join(self.current_directory, item)
                if os.path.isfile(item_path):
                    files.append(item)
                elif os.path.isdir(item_path):
                    folders.append(item)
            
            # Klas√∂rleri g√∂ster
            if folders:
                self.log_message("üìÅ Klas√∂rler:")
                for folder in sorted(folders):
                    self.log_message(f"  üìÅ {folder}")
            
            # Dosyalarƒ± g√∂ster
            if files:
                self.log_message("üìÑ Dosyalar:")
                for file in sorted(files):
                    # Git, sistem ve gereksiz dosyalarƒ± gizle
                    if not file.startswith('.') and file not in ['__pycache__', 'node_modules', 'build', 'dist', 'out', 'target']:
                        self.log_message(f"  üìÑ {file}")
            
            # README.md kontrol√º
            readme_path = os.path.join(self.current_directory, "README.md")
            if os.path.exists(readme_path):
                self.log_message("‚úÖ README.md dosyasƒ± bulundu")
                self.readme_var.set("keep")  # Otomatik olarak koru se√ßeneƒüini se√ß
            else:
                self.log_message("‚ÑπÔ∏è  README.md dosyasƒ± bulunamadƒ±")
                self.readme_var.set("create")  # Otomatik olarak olu≈ütur se√ßeneƒüini se√ß
            
            self.log_message("-" * 50)
            
        except Exception as e:
            self.log_message(f"‚ùå Klas√∂r i√ßeriƒüi listelenirken hata: {e}")

def main():
    """Ana uygulama - modern tasarƒ±m"""
    root = tk.Tk()
    
    # Modern tema ve stil ayarlarƒ±
    style = ttk.Style()
    style.theme_use('clam')
    
    # Pencere ikonu ve ba≈ülƒ±k
    try:
        root.iconbitmap("icon.ico")  # Eƒüer icon dosyasƒ± varsa
    except:
        pass  # Icon yoksa devam et
    
    # Modern pencere ayarlarƒ±
    root.configure(bg="#ffffff")
    root.option_add('*TFrame*background', '#ffffff')
    root.option_add('*TLabel*background', '#ffffff')
    
    app = GitAutoGUI(root)
    
    # Pencere kapatma olayƒ± - modern dialog
    def on_closing():
        if messagebox.askokcancel("üö™ √áƒ±kƒ±≈ü", 
                                 "GitAuto'dan √ßƒ±kmak istediƒüinizden emin misiniz?\n\n"
                                 "Kaydedilmemi≈ü deƒüi≈üiklikler kaybolabilir."):
            root.destroy()
    
    root.protocol("WM_DELETE_WINDOW", on_closing)
    
    # Pencereyi ekranƒ±n ortasƒ±na yerle≈ütir
    root.update_idletasks()
    x = (root.winfo_screenwidth() // 2) - (root.winfo_width() // 2)
    y = (root.winfo_screenheight() // 2) - (root.winfo_height() // 2)
    root.geometry(f"+{x}+{y}")
    
    # Pencereyi √∂ne getir
    root.lift()
    root.attributes('-topmost', True)
    root.after_idle(root.attributes, '-topmost', False)
    
    root.mainloop()

if __name__ == "__main__":
    main()

